//
// Copyright (c) 2025, Brian Frank and Andy Frank
// Licensed under the Academic Free License version 3.0
//
// History:
//   Dec 2025  Creation
//

using compiler

**
** Python type/class printer
**
class PyTypePrinter : PyPrinter
{
  new make(OutStream out) : super(out) {}

  ** Print a complete type definition
  Void type(TypeDef t)
  {
    m.curType = t

    // File header
    header(t)

    // Imports
    imports(t)

    // Class definition
    classDef(t)

    // Type metadata registration (for reflection)
    typeMetadata(t)

    m.curType = null
  }

//////////////////////////////////////////////////////////////////////////
// Header
//////////////////////////////////////////////////////////////////////////

  private Void header(TypeDef t)
  {
    w("#").nl
    w("# ${t.qname}").nl
    w("# Auto-generated by fanc py - do not edit").nl
    w("#").nl
    nl
  }

//////////////////////////////////////////////////////////////////////////
// Imports
//////////////////////////////////////////////////////////////////////////

  private Void imports(TypeDef t)
  {
    // Always import sys module for ObjUtil, etc.
    // Use fan.sys namespace to avoid Python's built-in sys module conflict
    w("import sys as sys_module").nl
    w("sys_module.path.insert(0, '.')").nl
    nl

    // Import base class (but skip if this IS Obj - no self-import)
    if (t.qname != "sys::Obj")
    {
      if (t.base != null && !t.base.isObj)
      {
        podPath := PyUtil.podImport(t.base.pod.name)
        w("from ${podPath}.${t.base.name} import ${t.base.name}").nl
      }
      else
      {
        w("from fan.sys.Obj import Obj").nl
      }
    }

    // Core sys utilities - always needed for runtime
    w("from fan.sys.ObjUtil import ObjUtil").nl
    w("from fan.sys import Bool").nl
    w("from fan.sys.Num import Num").nl
    w("from fan.sys.Int import Int").nl
    w("from fan.sys.Float import Float").nl
    w("from fan.sys.Str import Str").nl
    w("from fan.sys.Range import Range").nl
    w("from fan.sys.Map import Map").nl
    w("from fan.sys.List import List").nl
    w("from fan.sys.Duration import Duration").nl
    w("from fan.sys.Locale import Locale").nl
    w("from fan.sys.StrBuf import StrBuf").nl
    // Reflection types
    w("from fan.sys.Type import Type").nl
    w("from fan.sys.Pod import Pod").nl
    w("from fan.sys.Slot import Slot").nl
    w("from fan.sys.Method import Method").nl
    w("from fan.sys.Field import Field").nl
    w("from fan.sys.Func import Func").nl
    w("from fan.sys.Env import Env").nl
    w("from fan.sys.Unsafe import Unsafe, make").nl
    w("from fan.sys.Err import Err, ParseErr, NullErr, CastErr, ArgErr, IndexErr, UnsupportedErr, UnknownTypeErr, UnknownPodErr, UnknownSlotErr, UnknownServiceErr, ReadonlyErr, IOErr, NotImmutableErr, CancelledErr, ConstErr, InterruptedErr, NameErr, TimeoutErr").nl
    w("from fan.sys.Buf import Buf").nl
    w("from fan.sys.File import File").nl
    w("from fan.sys.Zip import Zip").nl
    w("from fan.sys.Process import Process").nl
    w("from fan.sys.Service import Service").nl
    // Additional runtime types
    w("from fan.sys.Regex import Regex, RegexMatcher").nl
    w("from fan.sys.Uri import Uri, UriScheme").nl
    w("from fan.sys.Unit import Unit").nl
    w("from fan.sys.MimeType import MimeType").nl
    w("from fan.sys.Charset import Charset").nl
    w("from fan.sys.Log import Log, LogLevel, LogRec").nl
    w("from fan.sys.Version import Version").nl
    w("from fan.sys.Weekday import Weekday").nl
    w("from fan.sys.TimeZone import TimeZone").nl
    w("from fan.sys.DateTime import DateTime, Month, Date, Time").nl
    w("from fan.sys.Uuid import Uuid").nl
    w("from fan.sys.Depend import Depend").nl
    w("from fan.sys.Decimal import Decimal").nl
    w("from fan.sys.Endian import Endian").nl
    w("from fan.sys.Enum import Enum").nl
    w("from fan.sys.Facet import Facet").nl
    w("from fan.sys.OutStream import OutStream").nl

    // Collect and import cross-pod types
    crossPodTypes := collectCrossPodTypes(t)
    crossPodTypes.each |types, podName|
    {
      if (podName == "sys") return  // Already imported above
      if (podName == t.pod.name) return  // Skip same-pod (handled at runtime)

      podPath := PyUtil.podImport(podName)
      types.each |typeName|
      {
        w("from ${podPath}.${typeName} import ${typeName}").nl
      }
    }

    // Import same-pod mixins that are used in class definition
    // These must be imported at module load time since Python needs base classes defined
    t.mixins.each |m|
    {
      if (m.qname == "sys::Obj") return  // Skip Obj
      if (m.pod.name == t.pod.name)
      {
        // Same-pod mixin - needs explicit import for class definition
        podPath := PyUtil.podImport(m.pod.name)
        w("from ${podPath}.${m.name} import ${m.name}").nl
      }
    }

    // NOTE: Other same-pod imports are handled at runtime via reflection or lazy imports
    // Automatic same-unit imports can cause circular import issues when helper classes
    // reference each other (e.g., FacetsA imports FacetsB imports FacetsA)

    nl
  }

  ** Collect all cross-pod type references from a TypeDef
  ** Returns a map of podName -> Set of type names
  private Str:Str[] collectCrossPodTypes(TypeDef t)
  {
    result := Str:Str[][:]

    // Helper to add a type reference
    addType := |CType? ctype|
    {
      if (ctype == null) return
      // Unwrap nullable, list, map, func types
      ctype = unwrapType(ctype)
      if (ctype == null) return
      if (ctype.isSynthetic) return

      podName := ctype.pod.name
      typeName := ctype.name

      // Skip sys pod (already imported) and same pod (runtime handled)
      if (podName == "sys") return
      if (podName == t.pod.name) return

      // Add to result
      if (result[podName] == null) result[podName] = Str[,]
      if (!result[podName].contains(typeName))
        result[podName].add(typeName)
    }

    // Helper to add by pod/type name
    addByName := |Str podName, Str? typeName|
    {
      if (podName == "sys") return
      if (podName == t.pod.name) return
      if (typeName == null) return

      if (result[podName] == null) result[podName] = Str[,]
      if (!result[podName].contains(typeName))
        result[podName].add(typeName)
    }

    // Scan using statements from the compilation unit
    // This catches types referenced in method bodies like Service.find()
    t.unit.usings.each |u|
    {
      // Skip FFI imports (e.g., [java]java.io::RandomAccessFile)
      if (u.podName.startsWith("[")) return

      if (u.typeName != null)
      {
        // Specific type import: using concurrent::Actor
        addByName(u.podName, u.typeName)
      }
      else
      {
        // Whole-pod import: using concurrent
        // For known pods, add common types that exist in transpiled output
        if (u.podName == "concurrent")
        {
          addByName("concurrent", "Actor")
          addByName("concurrent", "ActorPool")
          // Note: Service is actually in sys pod (native type)
        }
        else if (u.podName == "util")
        {
          addByName("util", "Random")
          addByName("util", "FileLogger")
        }
      }
    }

    // Base class and mixins
    if (t.base != null) addType(t.base)
    t.mixins.each |m| { addType(m) }

    // Field types
    t.fieldDefs.each |f|
    {
      addType(f.type)
    }

    // Method return types and parameter types
    t.methodDefs.each |m|
    {
      addType(m.returns)
      m.params.each |p|
      {
        addType(p.type)
      }
    }

    return result
  }

  ** Unwrap nullable, list, map, func types to get the base type
  private CType? unwrapType(CType? t)
  {
    if (t == null) return null
    // Unwrap nullable
    if (t.isNullable) t = t.toNonNullable
    // For list/map/func, we'd need to recurse, but for imports we just need the outer type
    return t
  }

//////////////////////////////////////////////////////////////////////////
// Class
//////////////////////////////////////////////////////////////////////////

  private Void classDef(TypeDef t)
  {
    // class ClassName(Mixin1, Mixin2, BaseClass):
    // Python supports multiple inheritance - include all mixins plus base class
    w("class ${t.name}")
    w("(")

    bases := Str[,]

    // Add mixins first (most specific to least specific order)
    // Filter out sys::Obj since it's always the root
    t.mixins.each |m|
    {
      if (m.qname != "sys::Obj")
        bases.add(m.name)
    }

    // Add base class
    if (t.base != null && !t.base.isObj)
      bases.add(t.base.name)
    else if (bases.isEmpty)
      bases.add("Obj")

    // Write the bases
    w(bases.join(", "))
    w(")")
    colon

    indent

    // Check if this is an enum type
    if (t.isEnum)
    {
      enumClassDef(t)
    }
    else
    {
      // Static fields (class-level attributes) - must come first
      staticFields(t)

      // Constructor
      ctor(t)

      // Field getters/setters (instance fields only)
      t.fieldDefs.each |f|
      {
        if (f.isStatic) return
        fieldAccessors(f)
      }

      // Methods - track which field accessors we've already emitted
      emittedAccessors := Str:Bool[:]
      t.methodDefs.each |m|
      {
        if (m.isCtor) return
        if (m.isInstanceInit) return
        if (m.isStaticInit) return
        // Allow once helper methods (synthetic but needed) - they end with $Once
        if (m.isSynthetic && !m.name.endsWith("\$Once")) return
        // Skip abstract methods in mixins - they must be implemented by concrete class
        // Python MRO would find the mixin's pass-returning method before the base class implementation
        if (m.isAbstract && t.isMixin) return

        // For field accessors, emit combined getter/setter only once
        if (m.isFieldAccessor)
        {
          fieldName := m.accessorFor.name
          if (emittedAccessors[fieldName] == true) return  // Already emitted
          emittedAccessors[fieldName] = true
          combinedFieldAccessor(m.accessorFor)
          return
        }

        method(m)
      }

      // If no methods, add pass
      if (t.methodDefs.isEmpty)
        pass
    }

    unindent
    nl
  }

//////////////////////////////////////////////////////////////////////////
// Enum
//////////////////////////////////////////////////////////////////////////

  ** Generate enum class definition
  private Void enumClassDef(TypeDef t)
  {
    enumFields := t.fieldDefs.findAll |f| { f.enumDef != null }
      .sort |a, b| { a.enumDef.ordinal <=> b.enumDef.ordinal }

    // Private cache field for vals
    nl
    w("_vals = None").nl

    // Static accessor for each enum value: A(), B(), C()
    enumFields.each |f|
    {
      def := f.enumDef
      nl
      w("@staticmethod").nl
      w("def ${escapeName(def.name)}()").colon
      indent
      w("return ${t.name}.vals().get(${def.ordinal})").eos
      unindent
    }

    // vals() method - creates and caches enum instances
    nl
    w("@staticmethod").nl
    w("def vals()").colon
    indent
    w("if ${t.name}._vals is None").colon
    indent
    w("${t.name}._vals = List.toImmutable(List.fromList([").nl
    indent
    enumFields.each |f, i|
    {
      def := f.enumDef
      w("${t.name}._make_enum(${def.ordinal}, ${def.name.toCode}")
      if (!def.ctorArgs.isEmpty)
      {
        def.ctorArgs.each |arg|
        {
          w(", ")
          PyExprPrinter(this).expr(arg)
        }
      }
      w(")")
      if (i < enumFields.size - 1) w(",")
      nl
    }
    unindent
    w("]))").eos
    unindent
    w("return ${t.name}._vals").eos
    unindent

    // fromStr() method
    nl
    w("@staticmethod").nl
    w("def fromStr(name, checked=True)").colon
    indent
    w("for v in ${t.name}.vals()").colon
    indent
    w("if v.name() == name").colon
    indent
    w("return v").eos
    unindent
    unindent
    w("if checked").colon
    indent
    w("raise ParseErr.make(\"Unknown enum: \" + name)").eos
    unindent
    w("return None").eos
    unindent

    // _make_enum() internal factory
    nl
    w("@staticmethod").nl
    w("def _make_enum(_ordinal, _name")
    // Add ctor params if enum has custom constructor (skip first 2: ordinal, name)
    ctorMethod := t.methodDefs.find |m| { m.isCtor }
    if (ctorMethod != null && ctorMethod.params.size > 2)
    {
      ctorMethod.params[2..-1].each |p|
      {
        w(", ")
        w(escapeName(p.name))
      }
    }
    w(")").colon
    indent
    w("inst = object.__new__(${t.name})").eos
    w("inst._ordinal = _ordinal").eos
    w("inst._name = _name").eos
    // Initialize custom fields (skip first 2: ordinal, name)
    if (ctorMethod != null && ctorMethod.params.size > 2)
    {
      ctorMethod.params[2..-1].each |p|
      {
        w("inst._${escapeName(p.name)} = ${escapeName(p.name)}").eos
      }
    }
    w("return inst").eos
    unindent

    // ordinal() method
    nl
    w("def ordinal(self)").colon
    indent
    w("return self._ordinal").eos
    unindent

    // name() method
    nl
    w("def name(self)").colon
    indent
    w("return self._name").eos
    unindent

    // toStr() returns the name
    nl
    w("def toStr(self)").colon
    indent
    w("return self._name").eos
    unindent

    // __str__ for Python
    nl
    w("def __str__(self)").colon
    indent
    w("return self._name").eos
    unindent

    // equals - enums are singletons, use identity
    nl
    w("def equals(self, other)").colon
    indent
    w("return self is other").eos
    unindent

    // compare by ordinal
    nl
    w("def compare(self, other)").colon
    indent
    w("return self._ordinal - other._ordinal").eos
    unindent

    // Python comparison operators
    nl
    w("def __lt__(self, other)").colon
    indent
    w("return self._ordinal < other._ordinal").eos
    unindent

    nl
    w("def __le__(self, other)").colon
    indent
    w("return self._ordinal <= other._ordinal").eos
    unindent

    nl
    w("def __gt__(self, other)").colon
    indent
    w("return self._ordinal > other._ordinal").eos
    unindent

    nl
    w("def __ge__(self, other)").colon
    indent
    w("return self._ordinal >= other._ordinal").eos
    unindent

    nl
    w("def __eq__(self, other)").colon
    indent
    w("if not isinstance(other, ${t.name})").colon
    indent
    w("return False").eos
    unindent
    w("return self._ordinal == other._ordinal").eos
    unindent

    nl
    w("def __hash__(self)").colon
    indent
    w("return hash(self._ordinal)").eos
    unindent

    // Field getters for custom fields (skip enum values and vals field)
    t.fieldDefs.each |f|
    {
      if (f.enumDef != null) return  // Skip enum value fields (A, B, C)
      if (f.name == "vals") return   // Skip vals - we generate our own static vals()
      if (f.isStatic) return         // Skip other static fields
      fieldAccessors(f)
    }

    // Additional methods (like negOrdinal in EnumAbc)
    t.methodDefs.each |m|
    {
      if (m.isCtor) return
      if (m.isInstanceInit) return
      if (m.isStaticInit) return
      if (m.isSynthetic) return
      if (m.name == "fromStr") return  // Already generated

      method(m)
    }
  }

//////////////////////////////////////////////////////////////////////////
// Constructor
//////////////////////////////////////////////////////////////////////////

  private Void ctor(TypeDef t)
  {
    // Find ALL constructors
    ctorMethods := t.methodDefs.findAll |m| { m.isCtor }

    // Separate static ctors (factories) from instance ctors
    // Static ctor: `static new make(...)` - just a factory, body should NOT go in __init__
    // Instance ctor: `new make(...)` - body goes in __init__
    instanceCtors := ctorMethods.findAll |m| { !m.isStatic }
    staticCtors := ctorMethods.findAll |m| { m.isStatic }

    // If no constructors, use a simple default
    if (ctorMethods.isEmpty)
    {
      // Generate static make() factory method with no params
      nl
      w("@staticmethod").nl
      w("def make()").colon
      indent
      w("return ${t.name}()").eos
      unindent

      // Generate __init__ constructor
      nl
      w("def __init__(self)").colon
      indent
      w("super().__init__()").eos
      // Instance field initialization
      t.fieldDefs.each |f|
      {
        if (f.isStatic) return
        fieldInit(f)
      }
      unindent
      nl
      return
    }

    // Find the primary constructor for __init__:
    // - Prefer instance ctor named "make", else first instance ctor
    // - If no instance ctors, use first static ctor but __init__ will have minimal body
    primaryCtor := instanceCtors.find |m| { m.name == "make" } ?: instanceCtors.first
    hasInstanceCtor := primaryCtor != null
    if (primaryCtor == null)
      primaryCtor = staticCtors.find |m| { m.name == "make" } ?: staticCtors.first

    // Generate static factory methods for ALL constructors
    ctorMethods.each |ctorMethod|
    {
      ctorName := ctorMethod.name  // "make", "make1", "make2", etc.
      isStaticFactory := ctorMethod.isStatic  // static new make(...) vs new make(...)

      nl
      w("@staticmethod").nl
      w("def ${ctorName}(")
      ctorMethod.params.each |p, i|
      {
        if (i > 0) w(", ")
        w(escapeName(p.name))
        if (p.hasDefault)
        {
          w("=None")
        }
      }
      w(")")
      colon
      indent

      // For static factories: run the factory body code (they call other ctors internally)
      // For instance ctors: create instance and run body
      if (isStaticFactory)
      {
        // Static factory - run the body code which creates/returns instance
        // The body will call other ctors like makeImpl or makeSegs
        emitDefaultParamChecks(ctorMethod)
        if (ctorMethod.code != null && !ctorMethod.code.stmts.isEmpty)
        {
          // Mark static context
          this.m.inStaticContext = true
          stmtPrinter := PyStmtPrinter(this)
          stmtPrinter.scanMethodForClosures(ctorMethod.code)
          ctorMethod.code.stmts.each |s, idx|
          {
            this.m.stmtIndex = idx
            stmtPrinter.stmt(s)
          }
          this.m.clearClosures()
          this.m.inStaticContext = false
        }
        else
        {
          pass
        }
      }
      else if (ctorName != "make")
      {
        // Named instance constructor (not "make") - create instance and run ctor body
        w("inst = object.__new__(${t.name})").eos

        // Check if this ctor chains to this.make() - if so, skip _ctor_init
        // because __init__() will handle field initialization
        chainsToThisMake := ctorMethod.ctorChain != null &&
          (ctorMethod.ctorChain.target == null || ctorMethod.ctorChain.target.id == ExprId.thisExpr) &&
          ctorMethod.ctorChain.method.name == "make"

        if (!chainsToThisMake)
        {
          w("inst._ctor_init()").eos  // Initialize fields only if not chaining to make()
        }

        // Call the instance body method with params
        w("inst._${ctorName}_body(")
        ctorMethod.params.each |p, i|
        {
          if (i > 0) w(", ")
          w(escapeName(p.name))
        }
        w(")").eos
        w("return inst").eos
      }
      else
      {
        // Primary instance make() just delegates to __init__
        w("return ${t.name}(")
        ctorMethod.params.each |p, i|
        {
          if (i > 0) w(", ")
          w(escapeName(p.name))
        }
        w(")").eos
      }
      unindent
    }

    // Generate instance body methods for named constructors
    ctorMethods.each |ctorMethod|
    {
      if (ctorMethod.name == "make") return  // Primary ctor uses __init__

      nl
      w("def _${ctorMethod.name}_body(self")
      ctorMethod.params.each |p|
      {
        w(", ")
        w(escapeName(p.name))
        if (p.hasDefault)
        {
          w("=None")
        }
      }
      w(")").colon
      indent

      emittedStmts := false

      // Handle constructor chaining (: this.make(...) or : super(...))
      if (ctorMethod.ctorChain != null)
      {
        chain := ctorMethod.ctorChain
        // Check if chaining to this or super
        isThisChain := chain.target == null || chain.target.id == ExprId.thisExpr
        isSuperChain := chain.target != null && chain.target.id == ExprId.superExpr

        if (isThisChain)
        {
          // this.make(...) - call another constructor on this type
          chainCtorName := chain.method.name
          if (chainCtorName == "make")
          {
            // Call __init__ directly to chain to primary constructor
            w("self.__init__(")
            chain.args.each |arg, i|
            {
              if (i > 0) w(", ")
              PyExprPrinter(this).expr(arg)
            }
            w(")").eos
          }
          else
          {
            // Chain to another named constructor's body
            w("self._${chainCtorName}_body(")
            chain.args.each |arg, i|
            {
              if (i > 0) w(", ")
              PyExprPrinter(this).expr(arg)
            }
            w(")").eos
          }
        }
        else if (isSuperChain)
        {
          // super(...) - call parent constructor with chain arguments
          // This re-calls parent's __init__ with actual arguments to set up parent fields
          chainCtorName := chain.method.name
          if (chainCtorName == "make")
          {
            // Call parent's __init__ with arguments
            w("super().__init__(")
            chain.args.each |arg, i|
            {
              if (i > 0) w(", ")
              PyExprPrinter(this).expr(arg)
            }
            w(")").eos
          }
          else
          {
            // Call parent's named constructor body
            w("super()._${chainCtorName}_body(")
            chain.args.each |arg, i|
            {
              if (i > 0) w(", ")
              PyExprPrinter(this).expr(arg)
            }
            w(")").eos
          }
        }
        emittedStmts = true
      }

      if (ctorMethod.code != null && !ctorMethod.code.stmts.isEmpty)
      {
        stmtPrinter := PyStmtPrinter(this)
        stmtPrinter.scanMethodForClosures(ctorMethod.code)
        ctorMethod.code.stmts.each |s, idx|
        {
          this.m.stmtIndex = idx
          // Skip synthetic return statements
          if (s.id == StmtId.returnStmt)
          {
            ret := s as ReturnStmt
            if (ret.expr == null || ret.isSynthetic) return
          }
          // Skip synthetic instance init calls and enterCtor/exitCtor (field-not-set checks)
          if (s.id == StmtId.expr)
          {
            exprStmt := s as ExprStmt
            if (exprStmt.expr.id == ExprId.call)
            {
              call := exprStmt.expr as CallExpr
              if (call.method.name.contains("\$init\$")) return
              // Skip Fantom's enterCtor/exitCtor field-not-set checking (not needed in Python)
              if (call.method.name == "enterCtor" || call.method.name == "exitCtor") return
            }
          }
          stmtPrinter.stmt(s)
          emittedStmts = true
        }
        this.m.clearClosures()
      }
      if (!emittedStmts)
      {
        pass
      }
      unindent
    }

    // Generate _ctor_init helper for field initialization (used by named ctors)
    if (ctorMethods.size > 1 || (ctorMethods.size == 1 && ctorMethods.first.name != "make"))
    {
      nl
      w("def _ctor_init(self)").colon
      indent
      // Only call super().__init__() if parent has no required ctor params
      // If parent has required params, call parent's _ctor_init() instead
      // This initializes parent fields without needing constructor arguments
      parentHasRequiredParams := t.base != null && !t.base.isObj &&
        t.base.ctors.any |ctor| { ctor.params.any |p| { !p.hasDefault } }
      parentHasMultipleCtors := t.base != null && !t.base.isObj && t.base.ctors.size > 1
      if (parentHasRequiredParams || parentHasMultipleCtors)
      {
        // Call parent's _ctor_init() to initialize parent fields
        w("super()._ctor_init()").eos
      }
      else
      {
        w("super().__init__()").eos
      }
      // Instance field initialization
      t.fieldDefs.each |f|
      {
        if (f.isStatic) return
        fieldInit(f)
      }
      // Instance init block
      instanceInitMethod := t.methodDefs.find |m| { m.isInstanceInit }
      if (instanceInitMethod != null && instanceInitMethod.code != null)
      {
        stmtPrinter := PyStmtPrinter(this)
        stmtPrinter.scanMethodForClosures(instanceInitMethod.code)
        instanceInitMethod.code.stmts.each |s, idx|
        {
          this.m.stmtIndex = idx
          stmtPrinter.stmt(s)
        }
        this.m.clearClosures()
      }
      unindent
    }

    // Generate __init__ constructor (uses primary ctor's signature)
    nl
    w("def __init__(self")

    // In Python, once we emit a default parameter, ALL following params must have defaults
    // Find the first index where we should start emitting defaults:
    // - explicit hasDefault, OR
    // - nullable type AND all following params also have defaults or are nullable
    firstDefaultIdx := primaryCtor.params.size
    for (i := primaryCtor.params.size - 1; i >= 0; i--)
    {
      p := primaryCtor.params[i]
      if (p.hasDefault || p.type.isNullable)
        firstDefaultIdx = i
      else
        break  // Found a required param, stop
    }

    primaryCtor.params.each |p, i|
    {
      w(", ")
      w(escapeName(p.name))
      // Only add =None if at or after firstDefaultIdx
      if (i >= firstDefaultIdx)
      {
        w("=None")
      }
    }
    w(")")
    colon

    indent

    // Emit default parameter value checks at start of constructor body
    // This follows the JavaScript transpiler pattern
    emitDefaultParamChecks(primaryCtor)

    // Call super().__init__() with constructor chain arguments
    w("super().__init__(")
    if (primaryCtor.ctorChain != null)
    {
      chain := primaryCtor.ctorChain
      chain.args.each |arg, i|
      {
        if (i > 0) w(", ")
        PyExprPrinter(this).expr(arg)
      }
    }
    w(")").eos

    // Instance field initialization
    t.fieldDefs.each |f|
    {
      if (f.isStatic) return
      fieldInit(f)
    }

    // Instance init block
    instanceInitMethod := t.methodDefs.find |m| { m.isInstanceInit }
    if (instanceInitMethod != null && instanceInitMethod.code != null)
    {
      stmtPrinter := PyStmtPrinter(this)
      stmtPrinter.scanMethodForClosures(instanceInitMethod.code)
      instanceInitMethod.code.stmts.each |s, idx|
      {
        this.m.stmtIndex = idx
        // Skip synthetic return statements (same filtering as primary ctor body)
        if (s.id == StmtId.returnStmt)
        {
          ret := s as ReturnStmt
          if (ret.expr == null || ret.isSynthetic) return
        }
        stmtPrinter.stmt(s)
      }
      this.m.clearClosures()
    }

    // Primary constructor body
    // ONLY emit body if primaryCtor is an instance ctor (not a static factory)
    // Static factories (static new make(...)) should NOT have their body in __init__
    // because they return newly constructed instances, not modify `self`
    if (hasInstanceCtor && primaryCtor.code != null)
    {
      stmtPrinter := PyStmtPrinter(this)
      stmtPrinter.scanMethodForClosures(primaryCtor.code)

      primaryCtor.code.stmts.each |s, idx|
      {
        this.m.stmtIndex = idx
        // Skip synthetic return statements
        if (s.id == StmtId.returnStmt)
        {
          ret := s as ReturnStmt
          if (ret.expr == null || ret.isSynthetic) return
          // Skip return statements that return construction calls (factory pattern)
          // These are static factory returns, not instance initialization
          if (ret.expr.id == ExprId.call || ret.expr.id == ExprId.construction) return
        }
        // Skip synthetic instance init calls and enterCtor/exitCtor (field-not-set checks)
        if (s.id == StmtId.expr)
        {
          exprStmt := s as ExprStmt
          if (exprStmt.expr.id == ExprId.call)
          {
            call := exprStmt.expr as CallExpr
            if (call.method.name.contains("\$init\$")) return
            // Skip Fantom's enterCtor/exitCtor field-not-set checking (not needed in Python)
            if (call.method.name == "enterCtor" || call.method.name == "exitCtor") return
          }
        }
        stmtPrinter.stmt(s)
      }
    }

    // Clear closure state
    this.m.clearClosures()

    unindent
    nl
  }

  private Void fieldInit(FieldDef f)
  {
    w("self._${escapeName(f.name)} = ")
    if (f.init != null)
      PyExprPrinter(this).expr(f.init)
    else
      w(defaultVal(f.type))
    eos
  }

  private Void fieldAccessors(FieldDef f)
  {
    // Skip if field has custom get/set accessors
    // Custom accessors are generated via combinedFieldAccessor() call below
    if (f.hasGet || f.hasSet) return

    name := escapeName(f.name)

    // Generate combined getter/setter: def fieldName(self, _val_=None):
    // This is required because PyExprPrinter.assign() uses method call syntax
    // for field assignments on transpiled types: target.fieldName(value)
    nl
    w("def ${name}(self, _val_=None)").colon
    indent
    w("if _val_ is None").colon
    indent
    w("return self._${name}").eos
    unindent
    w("else").colon
    indent
    w("self._${name} = _val_").eos
    unindent
    unindent
  }

  ** Default value for uninitialized fields.
  ** In Fantom:
  ** - Nullable types (?) always default to null
  ** - Non-nullable primitives (Int, Float, Bool) have type defaults (0, 0.0, false)
  ** - Non-nullable reference types (Str, List, etc.) start as null, must be initialized
  private Str defaultVal(CType t)
  {
    // Nullable types always default to None
    if (t.isNullable) return "None"

    sig := t.signature
    // Non-nullable primitives have type-specific defaults
    if (sig == "sys::Bool") return "False"
    if (sig == "sys::Int") return "0"
    if (sig == "sys::Float") return "0.0"

    // Non-nullable reference types (Str, List, etc.) start as None
    // They must be initialized by constructor - Fantom's type system enforces this
    return "None"
  }

  ** Type-specific default for static field getter fallback
  ** Used only when static field getter finds None after _static_init()
  private Str typeDefaultVal(CType t)
  {
    if (t.isNullable) return "None"
    sig := t.signature
    if (sig == "sys::Bool") return "False"
    if (sig == "sys::Int") return "0"
    if (sig == "sys::Float") return "0.0"
    if (sig == "sys::Str") return "\"\""
    return "None"
  }

//////////////////////////////////////////////////////////////////////////
// Static Fields
//////////////////////////////////////////////////////////////////////////

  ** Generate static fields with class-level storage and lazy-init getters
  ** Follows the JavaScript transpiler pattern from JsType.writeStaticField()
  private Void staticFields(TypeDef t)
  {
    // Find all static fields (excluding synthetic)
    staticFieldDefs := t.fieldDefs.findAll |f| { f.isStatic && !f.isSynthetic }
    if (staticFieldDefs.isEmpty) return

    // Check if there's a staticInit method
    staticInitMethod := t.methodDefs.find |m| { m.isStaticInit }

    // Generate class-level storage for each static field
    nl
    staticFieldDefs.each |f|
    {
      w("_${escapeName(f.name)} = None").nl
    }

    // Generate static getter for each static field
    staticFieldDefs.each |f|
    {
      staticFieldGetter(t, f, staticInitMethod != null)
    }

    // Generate _static_init() method if there's a staticInit block or fields need init
    if (staticInitMethod != null || staticFieldDefs.any |f| { f.init != null })
    {
      staticInit(t, staticInitMethod, staticFieldDefs)
    }
  }

  ** Generate static getter method for a static field
  private Void staticFieldGetter(TypeDef t, FieldDef f, Bool hasStaticInit)
  {
    name := escapeName(f.name)
    typeName := t.name

    nl
    w("@staticmethod").nl
    w("def ${name}()").colon
    indent

    // Check if uninitialized, then initialize
    w("if ${typeName}._${name} is None").colon
    indent
    if (hasStaticInit || f.init != null)
    {
      w("${typeName}._static_init()").eos
    }
    // If still None after static init, use type-specific default value
    w("if ${typeName}._${name} is None").colon
    indent
    w("${typeName}._${name} = ${typeDefaultVal(f.type)}").eos
    unindent
    unindent

    w("return ${typeName}._${name}").eos
    unindent
  }

  ** Generate _static_init() method that initializes all static fields
  ** Follows Fantom's source order: static blocks run before fields declared after them
  private Void staticInit(TypeDef t, MethodDef? staticInitMethod, FieldDef[] staticFieldDefs)
  {
    typeName := t.name

    nl
    w("@staticmethod").nl
    w("def _static_init()").colon
    indent

    // Add re-entry guard to prevent infinite recursion
    // This handles circular dependencies between static fields
    w("if hasattr(${typeName}, '_static_init_in_progress') and ${typeName}._static_init_in_progress").colon
    indent
    w("return").eos
    unindent
    w("${typeName}._static_init_in_progress = True").eos

    // Mark that we're in a static context (no 'self' available)
    m.inStaticContext = true

    // If there's a static init method, it contains EVERYTHING (Fantom compiler combines
    // all static initialization into one method). Just emit it, skipping the final return
    // so we can clear the guard flag after.
    if (staticInitMethod != null && staticInitMethod.code != null)
    {
      stmtPrinter := PyStmtPrinter(this)
      stmtPrinter.scanMethodForClosures(staticInitMethod.code)
      staticInitMethod.code.stmts.each |s, idx|
      {
        this.m.stmtIndex = idx
        // Skip synthetic return at end - we'll handle cleanup after
        if (s.id == StmtId.returnStmt)
        {
          ret := s as ReturnStmt
          if (ret.expr == null) return  // Skip void return
        }
        stmtPrinter.stmt(s)
      }
      this.m.clearClosures()
    }
    else
    {
      // No static block - just initialize fields with inline initializers
      staticFieldDefs.each |f|
      {
        if (f.init == null) return
        name := escapeName(f.name)
        w("if ${typeName}._${name} is None").colon
        indent
        w("${typeName}._${name} = ")
        PyExprPrinter(this).expr(f.init)
        eos
        unindent
      }
    }

    // Clear the re-entry guard
    w("${typeName}._static_init_in_progress = False").eos

    // Reset static context flag
    m.inStaticContext = false

    unindent
  }

  ** Generate combined getter/setter method for fields with custom accessors
  ** In Python, we combine them into one method with optional parameter
  private Void combinedFieldAccessor(FieldDef f)
  {
    name := escapeName(f.name)

    // Generate: def fieldName(self, _val_=None):
    //   if _val_ is None:
    //     # getter body
    //   else:
    //     # setter body
    nl
    w("def ${name}(self, _val_=None)").colon
    indent
    nl

    w("if _val_ is None").colon
    indent
    // Getter body
    if (f.get != null && f.get.code != null)
    {
      stmtPrinter := PyStmtPrinter(this)
      stmtPrinter.scanMethodForClosures(f.get.code)
      f.get.code.stmts.each |s, idx|
      {
        this.m.stmtIndex = idx
        stmtPrinter.stmt(s)
      }
      this.m.clearClosures()
    }
    else
    {
      w("return self._${name}").eos
    }
    unindent

    w("else").colon
    indent
    // Setter body - need to replace 'it' param with '_val_'
    if (f.set != null && f.set.code != null)
    {
      // Map 'it' to '_val_' for the setter body
      w("it = _val_").eos
      stmtPrinter := PyStmtPrinter(this)
      stmtPrinter.scanMethodForClosures(f.set.code)
      f.set.code.stmts.each |s, idx|
      {
        this.m.stmtIndex = idx
        stmtPrinter.stmt(s)
      }
      this.m.clearClosures()
    }
    else
    {
      w("self._${name} = _val_").eos
    }
    unindent

    unindent
  }

//////////////////////////////////////////////////////////////////////////
// Methods
//////////////////////////////////////////////////////////////////////////

  private Void method(MethodDef m)
  {
    this.m.curMethod = m

    // Set static context flag for static methods
    // This ensures calls like self.make() become ClassName.make()
    if (m.isStatic)
      this.m.inStaticContext = true

    nl

    // Static decorator
    if (m.isStatic)
      w("@staticmethod").nl

    // def method_name(self, params...):
    w("def ${escapeName(m.name)}(")
    if (!m.isStatic) w("self")

    m.params.each |p, i|
    {
      if (i > 0 || !m.isStatic) w(", ")
      w(escapeName(p.name))
      if (p.hasDefault)
      {
        w("=None")  // Default params simplified for bootstrap
      }
    }
    w(")")
    colon

    // Method body
    if (m.code == null || m.code.stmts.isEmpty)
    {
      indent
      // Even empty methods need default parameter handling
      emitDefaultParamChecks(m)
      if (!m.params.any |p| { p.hasDefault })
        pass
      unindent
    }
    else
    {
      indent

      // Emit default parameter value checks at start of method body
      // This follows the JavaScript transpiler pattern from JsType.doWriteMethod()
      emitDefaultParamChecks(m)

      // Scan method for closures to track usage
      stmtPrinter := PyStmtPrinter(this)
      stmtPrinter.scanMethodForClosures(m.code)

      // Emit statements (closures emitted lazily)
      m.code.stmts.each |s, idx|
      {
        this.m.stmtIndex = idx
        stmtPrinter.stmt(s)
      }

      unindent
    }

    // Clear closure state for next method
    this.m.clearClosures()

    // Generate Python main block for main() methods
    if (isMain(m))
      pyMain(m)

    // Reset static context flag
    if (m.isStatic)
      this.m.inStaticContext = false

    this.m.curMethod = null
  }

  ** Emit default parameter value checks at start of method body
  ** Follows JS transpiler pattern: if (param === undefined) param = defaultExpr;
  ** For Python: if param is None: param = defaultExpr
  private Void emitDefaultParamChecks(MethodDef m)
  {
    m.params.each |p|
    {
      if (!p.hasDefault) return
      name := escapeName(p.name)

      // Generate: if param is None: param = defaultValue
      w("if ${name} is None").colon
      indent
      w("${name} = ")
      // p.def_ is the default value expression - transpile it
      PyExprPrinter(this).expr(p->def)
      eos
      unindent
    }
  }

  ** Check if this is a main(Str[] args) method
  private Bool isMain(MethodDef m)
  {
    m.name == "main" && m.params.size == 1 && m.params[0].type.isList
  }

  ** Generate Python main block
  private Void pyMain(MethodDef m)
  {
    nl
    nl
    w("if __name__ == \"__main__\":").nl
    indent
    typeName := m.parent.name
    w("import sys as sys_mod").nl
    w("main_instance = ${typeName}()").nl
    w("main_instance.main(sys_mod.argv[1:])").nl
    unindent
  }

//////////////////////////////////////////////////////////////////////////
// Type Metadata (Reflection)
//////////////////////////////////////////////////////////////////////////

  ** Generate type metadata registration for reflection
  ** This is similar to how JsPod.writeTypeInfo() works for JavaScript
  private Void typeMetadata(TypeDef t)
  {
    // Skip synthetic types
    if (t.isSynthetic) return

    // Check if we have any slots to register
    hasSlots := t.fieldDefs.any |f| { !f.isSynthetic } ||
                t.methodDefs.any |m| { !m.isSynthetic && !m.isInstanceInit && !m.isStaticInit }

    // Always need to emit tf_() for type-level metadata (facets, mixins, base type)
    // even if there are no slots (e.g., mixins with only inherited members)
    hasFacets := t.facets != null && !t.facets.isEmpty
    hasMixins := !t.mixins.isEmpty && t.mixins.any |m| { m.qname != "sys::Obj" }
    hasBase := t.base != null && !t.base.isObj

    // Skip only if there's nothing to register
    if (!hasSlots && !hasFacets && !hasMixins && !hasBase) return

    nl
    w("# Type metadata registration for reflection").nl
    w("from fan.sys.Param import Param").nl
    w("from fan.sys.Slot import FConst").nl
    w("_t = Type.find('${t.qname}')").nl

    // Calculate type flags
    typeFlags := typeFlags(t)

    // Build mixin list
    mixinList := Str[,]
    t.mixins.each |m|
    {
      if (m.qname != "sys::Obj")
        mixinList.add("'${m.qname}'")
    }
    mixinsStr := "[" + mixinList.join(", ") + "]"

    // Register type-level facets with flags, mixins, and base type
    typeFacets := facetDict(t.facets)
    // Enums implicitly have @Serializable{simple=true}
    if (t.isEnum)
    {
      if (typeFacets == "{}")
        typeFacets = "{'sys::Serializable': {'simple': True}}"
      else if (!typeFacets.contains("sys::Serializable"))
        typeFacets = typeFacets[0..-2] + ", 'sys::Serializable': {'simple': True}}"
    }
    // Determine base type (non-Obj)
    baseStr := "None"
    if (t.base != null && !t.base.isObj)
      baseStr = "'${t.base.qname}'"
    // Always emit tf_() with flags, mixins, and base
    w("_t.tf_(${typeFacets}, ${typeFlags}, ${mixinsStr}, ${baseStr})").nl

    // Register fields (including enum value fields)
    t.fieldDefs.each |f|
    {
      if (f.isSynthetic) return

      flags := fieldFlags(f)
      typeSig := f.type.signature
      fieldFacets := "{}"

      // Enum value fields get special flag handling and may have facets
      if (f.enumDef != null)
      {
        // Enum values are public static const
        enumFlags := 0x00000001.or(0x00000800).or(0x00002000).or(0x00000020)  // Public | Static | Const | Enum
        fieldFacets = facetDict(f.enumDef.facets)
        w("_t.af_('${f.name}', ${enumFlags}, '${typeSig}', ${fieldFacets})").nl
      }
      else
      {
        fieldFacets = facetDict(f.facets)
        setterFlags := setterFlags(f)
        // Only emit setter flags if they differ from field flags
        if (setterFlags != flags)
          w("_t.af_('${f.name}', ${flags}, '${typeSig}', ${fieldFacets}, ${setterFlags})").nl
        else
          w("_t.af_('${f.name}', ${flags}, '${typeSig}', ${fieldFacets})").nl
      }
    }

    // Register methods
    t.methodDefs.each |m|
    {
      if (m.isSynthetic) return
      if (m.isInstanceInit) return
      if (m.isStaticInit) return
      if (m.isFieldAccessor) return

      flags := methodFlags(m)
      retSig := m.returns.signature
      methodFacets := facetDict(m.facets)

      // Build params list
      if (m.params.isEmpty)
      {
        w("_t.am_('${m.name}', ${flags}, '${retSig}', [], ${methodFacets})").nl
      }
      else
      {
        w("_t.am_('${m.name}', ${flags}, '${retSig}', [")
        m.params.each |p, i|
        {
          if (i > 0) w(", ")
          pType := p.type.signature
          hasDefault := p.hasDefault ? "True" : "False"
          w("Param('${p.name}', Type.find('${pType}'), ${hasDefault})")
        }
        w("], ${methodFacets})").nl
      }
    }
  }

  ** Serialize facets to Python dict format: {'sys::Serializable': {'simple': True}}
  private Str facetDict(FacetDef[]? facets)
  {
    if (facets == null || facets.isEmpty) return "{}"

    s := StrBuf()
    s.addChar('{')
    facets.each |f, i|
    {
      if (i > 0) s.add(", ")
      s.addChar('\'').add(f.type.qname).add("': ")

      // Build the facet value dict
      if (f.names.isEmpty)
      {
        s.add("{}")
      }
      else
      {
        s.addChar('{')
        f.names.each |name, j|
        {
          if (j > 0) s.add(", ")
          s.addChar('\'').add(name).add("': ")
          // Serialize the value - convert to Python literal
          val := f.vals[j]
          s.add(exprToPython(val))
        }
        s.addChar('}')
      }
    }
    s.addChar('}')
    return s.toStr
  }

  ** Convert a Fantom expression to a Python literal string
  private Str exprToPython(Expr e)
  {
    if (e is LiteralExpr)
    {
      lit := e as LiteralExpr
      val := lit.val
      if (val == null) return "None"
      if (val is Bool) return val == true ? "True" : "False"
      if (val is Int) return val.toStr
      if (val is Float) return val.toStr
      if (val is Str) return val.toStr.toCode
      return val.toStr.toCode
    }
    // Fallback - use Fantom's serialization
    return e.serialize.toCode
  }

  ** Calculate field flags
  private Int fieldFlags(FieldDef f)
  {
    flags := 0
    if (f.isPublic) flags = flags.or(0x00000001)       // FConst.Public
    if (f.isPrivate) flags = flags.or(0x00000002)      // FConst.Private
    if (f.isProtected) flags = flags.or(0x00000004)    // FConst.Protected
    if (f.isInternal) flags = flags.or(0x00000008)     // FConst.Internal
    if (f.isStatic) flags = flags.or(0x00000800)       // FConst.Static
    if (f.isVirtual) flags = flags.or(0x00001000)      // FConst.Virtual
    if (f.isOverride) flags = flags.or(0x00000200)     // FConst.Override
    if (f.isConst) flags = flags.or(0x00002000)        // FConst.Const
    return flags
  }

  ** Calculate setter-specific flags
  ** For fields like "Int x { private set }", the setter has different visibility
  ** than the field itself. Returns setter flags if f.set exists, otherwise field flags.
  private Int setterFlags(FieldDef f)
  {
    // If field has no setter accessor method, use field flags
    if (f.set == null) return fieldFlags(f)

    // FConst protection values in the compiler (different from Python emission values!)
    // FConst: Internal=0x80, Private=0x800, Protected=0x1000, Public=0x2000
    setFlags := f.set.flags

    // Check setter's protection using FConst values
    isSetterPublic := setFlags.and(0x00002000) != 0
    isSetterPrivate := setFlags.and(0x00000800) != 0
    isSetterProtected := setFlags.and(0x00001000) != 0
    isSetterInternal := setFlags.and(0x00000080) != 0

    // If setter has no protection flags, inherit from field
    if (!isSetterPublic && !isSetterPrivate && !isSetterProtected && !isSetterInternal)
      return fieldFlags(f)

    // Build output flags using Python-compatible values
    // Python emission values: Public=0x1, Private=0x2, Protected=0x4, Internal=0x8
    flags := 0
    if (isSetterPublic) flags = flags.or(0x00000001)
    if (isSetterPrivate) flags = flags.or(0x00000002)
    if (isSetterProtected) flags = flags.or(0x00000004)
    if (isSetterInternal) flags = flags.or(0x00000008)

    // Non-protection flags from field (using Python emission values)
    if (f.isStatic) flags = flags.or(0x00000800)       // Static
    if (f.isVirtual) flags = flags.or(0x00001000)      // Virtual
    if (f.isOverride) flags = flags.or(0x00000200)     // Override
    if (f.isConst) flags = flags.or(0x00002000)        // Const

    return flags
  }

  ** Calculate method flags
  private Int methodFlags(MethodDef m)
  {
    flags := 0
    if (m.isPublic) flags = flags.or(0x00000001)       // FConst.Public
    if (m.isPrivate) flags = flags.or(0x00000002)      // FConst.Private
    if (m.isProtected) flags = flags.or(0x00000004)    // FConst.Protected
    if (m.isInternal) flags = flags.or(0x00000008)     // FConst.Internal
    if (m.isCtor) flags = flags.or(0x00000100)         // FConst.Ctor
    if (m.isStatic) flags = flags.or(0x00000800)       // FConst.Static
    if (m.isVirtual) flags = flags.or(0x00001000)      // FConst.Virtual
    if (m.isAbstract) flags = flags.or(0x00000400)     // FConst.Abstract
    if (m.isOverride) flags = flags.or(0x00000200)     // FConst.Override
    return flags
  }

  ** Calculate type flags (Mixin, Facet, Internal, etc.)
  private Int typeFlags(TypeDef t)
  {
    flags := 0
    if (t.isPublic) flags = flags.or(0x00000001)       // FConst.Public
    if (t.isInternal) flags = flags.or(0x00000008)     // FConst.Internal
    if (t.isAbstract) flags = flags.or(0x00000400)     // FConst.Abstract
    if (t.isFinal) flags = flags.or(0x00010000)        // FConst.Final
    if (t.isMixin) flags = flags.or(0x00020000)        // FConst.Mixin
    if (t.isEnum) flags = flags.or(0x00040000)         // FConst.Enum
    if (t.isFacet) flags = flags.or(0x00080000)        // FConst.Facet
    return flags
  }

  ** Check if a statement is a static field assignment for one of the given fields
  ** Used to skip duplicate initializations in static init blocks
  private Bool isStaticFieldAssignment(Stmt s, Str[] fieldNames)
  {
    // Check for expression statement with assignment
    if (s.id != StmtId.expr) return false
    exprStmt := s as ExprStmt
    if (exprStmt.expr.id != ExprId.assign) return false

    // Check if LHS is a field reference
    assignExpr := exprStmt.expr as BinaryExpr
    if (assignExpr.lhs.id != ExprId.field) return false

    fieldExpr := assignExpr.lhs as FieldExpr
    if (!fieldExpr.field.isStatic) return false

    // Check if the field name is in our list
    return fieldNames.contains(fieldExpr.field.name)
  }
}
