//
// Copyright (c) 2025, Brian Frank and Andy Frank
// Licensed under the Academic Free License version 3.0
//
// History:
//   25 Feb 2026  Trevor Adelman  Creation
//

using compiler

**
** PyTypePrinter generates Python class files from Fantom TypeDefs.
**
** Output Structure (per file):
**   1. Header comment (auto-generated notice)
**   2. Imports:
**      - sys path setup
**      - typing imports (Optional, Callable, etc.)
**      - pod namespace imports (from fan import sys)
**      - base class and mixin direct imports
**      - exception types for catch clauses
**   3. Class definition:
**      - Static fields (class-level storage + lazy getters)
**      - Constructor (__init__ + factory methods like make())
**      - Field accessors (combined getter/setter pattern)
**      - Methods (instance and static)
**      - Python operator methods (__add__, __getitem__, etc.)
**   4. Type metadata registration (for reflection)
**
** Key Design Decisions:
**   - Enums use factory pattern with _make_enum() and lazy vals()
**   - Static fields use _static_init() with re-entry guard
**   - Named constructors use _ctorName_body() pattern
**   - See design.md in this directory for full documentation
**
class PyTypePrinter : PyPrinter
{
  new make(OutStream out) : super(out) {}

  ** Print a complete type definition
  Void type(TypeDef t)
  {
    m.curType = t

    // File header
    header(t)

    // Imports
    imports(t)

    // Class definition
    classDef(t)

    // Type metadata registration (for reflection)
    typeMetadata(t)

    // Generate if __name__ == "__main__" block at module level for main() methods
    // This MUST be after the class definition ends (unindented to module level)
    mainMethod := t.methodDefs.find |method| { isMain(method) }
    if (mainMethod != null)
      pyMain(mainMethod)

    m.curType = null
  }

//////////////////////////////////////////////////////////////////////////
// Header
//////////////////////////////////////////////////////////////////////////

  private Void header(TypeDef t)
  {
    w("#").nl
    w("# ${t.qname}").nl
    w("# Auto-generated by fanc py - do not edit").nl
    w("#").nl
    // Import global sentinel from sys for field getter/setter disambiguation
    w("from fan.sys.ObjUtil import _UNSET").nl
    nl
  }

//////////////////////////////////////////////////////////////////////////
// Imports
//////////////////////////////////////////////////////////////////////////

  private Void imports(TypeDef t)
  {
    // System path setup
    w("import sys as sys_module").nl
    w("sys_module.path.insert(0, '.')").nl
    nl

    // Type hint imports (Python 3.9+ uses native types, but we use typing for compatibility)
    w("from typing import Optional, Callable, List as TypingList, Dict as TypingDict").nl
    nl

    // For types NOT in sys pod: Import sys pod as namespace (lazy loader)
    // For types IN sys pod: Import Type directly (needed for metadata registration)
    if (t.pod.name != "sys")
    {
      w("from fan import sys").nl
    }
    else
    {
      // For sys pod types, import Type directly for metadata registration
      if (t.qname != "sys::Type")
        w("from fan.sys.Type import Type").nl

      // For sys pod enums, import List directly (used in vals() method)
      if (t.isEnum)
        w("from fan.sys.List import List").nl
    }

    // Import base class directly (needed for Python class definition)
    if (t.qname != "sys::Obj")
    {
      if (t.base != null && !t.base.isObj)
      {
        podPath := PyUtil.podImport(t.base.pod.name)
        w("from ${podPath}.${t.base.name} import ${t.base.name}").nl
      }
      else
      {
        w("from fan.sys.Obj import Obj").nl
      }
    }

    // Import ObjUtil directly (used everywhere)
    w("from fan.sys.ObjUtil import ObjUtil").nl

    // Import mixins directly (needed for Python class definition)
    t.mixins.each |m|
    {
      if (m.qname == "sys::Obj") return  // Skip Obj
      podPath := PyUtil.podImport(m.pod.name)
      w("from ${podPath}.${m.name} import ${m.name}").nl
    }

    // Import dependent pods as namespaces
    t.pod.depends.each |depend|
    {
      podName := depend.name
      if (podName == "sys") return  // Already imported above (or skipped for sys pod)
      if (podName == t.pod.name) return  // Skip same pod
      if (podName.startsWith("[")) return  // Skip FFI
      if (PyUtil.isJavaFfi(podName)) return

      // Escape reserved pod names (e.g., "def" -> "def_")
      escapedPod := PyUtil.escapePodName(podName)
      w("from fan import ${escapedPod}").nl
    }

    // Exception types used in catch clauses need explicit imports
    // because Python's except clause needs the class in local scope
    samePodCatchTypes := collectSamePodCatchTypes(t)
    samePodCatchTypes.each |typeName|
    {
      if (typeName == t.name) return  // Skip self-import
      podPath := PyUtil.podImport(t.pod.name)
      w("from ${podPath}.${typeName} import ${typeName}").nl
    }

    // Cross-pod exception types used in catch clauses also need explicit imports
    crossPodCatchTypes := collectCrossPodCatchTypes(t)
    crossPodCatchTypes.each |typeNames, podName|
    {
      podPath := PyUtil.podImport(podName)
      typeNames.each |typeName|
      {
        w("from ${podPath}.${typeName} import ${typeName}").nl
      }
    }

    nl
  }

//////////////////////////////////////////////////////////////////////////
// Import Scanning
//////////////////////////////////////////////////////////////////////////

  // These methods scan the AST to collect type references for imports.
  // Python requires explicit imports (unlike JS which bundles everything).
  // Key patterns handled:
  //   - Cross-pod exception types used in catch clauses
  //   - Same-pod exception types (Python except clause needs local scope)

  ** Collect cross-pod exception types used in catch clauses
  ** Returns a map of podName -> list of type names
  private Str:Str[] collectCrossPodCatchTypes(TypeDef t)
  {
    result := Str:Str[][:]

    // Scan all methods for catch clauses with cross-pod exception types
    t.methodDefs.each |m|
    {
      if (m.code != null)
        scanBlockForCrossPodCatchTypes(m.code, t.pod.name, result)
    }

    return result
  }

  ** Scan a block for cross-pod catch types
  private Void scanBlockForCrossPodCatchTypes(Block block, Str curPodName, Str:Str[] result)
  {
    block.stmts.each |stmt|
    {
      if (stmt.id == StmtId.tryStmt)
      {
        tryStmt := stmt as TryStmt
        tryStmt.catches.each |c|
        {
          if (c.errType != null)
          {
            errPod := c.errType.pod.name
            errName := c.errType.name
            // Cross-pod: not sys (already imported) and not same pod
            if (errPod != "sys" && errPod != curPodName)
            {
              if (result[errPod] == null) result[errPod] = Str[,]
              if (!result[errPod].contains(errName))
                result[errPod].add(errName)
            }
          }
        }
        // Recurse into try block
        scanBlockForCrossPodCatchTypes(tryStmt.block, curPodName, result)
        tryStmt.catches.each |c| { scanBlockForCrossPodCatchTypes(c.block, curPodName, result) }
        if (tryStmt.finallyBlock != null)
          scanBlockForCrossPodCatchTypes(tryStmt.finallyBlock, curPodName, result)
      }
      else if (stmt.id == StmtId.ifStmt)
      {
        ifStmt := stmt as IfStmt
        scanBlockForCrossPodCatchTypes(ifStmt.trueBlock, curPodName, result)
        if (ifStmt.falseBlock != null) scanBlockForCrossPodCatchTypes(ifStmt.falseBlock, curPodName, result)
      }
      else if (stmt.id == StmtId.forStmt)
      {
        forStmt := stmt as ForStmt
        if (forStmt.block != null) scanBlockForCrossPodCatchTypes(forStmt.block, curPodName, result)
      }
      else if (stmt.id == StmtId.whileStmt)
      {
        whileStmt := stmt as WhileStmt
        scanBlockForCrossPodCatchTypes(whileStmt.block, curPodName, result)
      }
      else if (stmt.id == StmtId.switchStmt)
      {
        switchStmt := stmt as SwitchStmt
        switchStmt.cases.each |c| { scanBlockForCrossPodCatchTypes(c.block, curPodName, result) }
        if (switchStmt.defaultBlock != null) scanBlockForCrossPodCatchTypes(switchStmt.defaultBlock, curPodName, result)
      }
    }
  }

  ** Collect same-pod exception types used in catch clauses
  ** These need explicit imports because they're used at statement level
  private Str[] collectSamePodCatchTypes(TypeDef t)
  {
    result := Str[,]

    // Scan all methods for catch clauses
    t.methodDefs.each |m|
    {
      if (m.code != null)
        scanBlockForCatchTypes(m.code, t.pod.name, result)
    }

    return result
  }

  ** Scan a block for same-pod catch types
  private Void scanBlockForCatchTypes(Block block, Str podName, Str[] result)
  {
    block.stmts.each |stmt|
    {
      if (stmt.id == StmtId.tryStmt)
      {
        tryStmt := stmt as TryStmt
        tryStmt.catches.each |c|
        {
          if (c.errType != null && c.errType.pod.name == podName)
          {
            typeName := c.errType.name
            if (!result.contains(typeName))
              result.add(typeName)
          }
        }
        // Recurse into try block
        scanBlockForCatchTypes(tryStmt.block, podName, result)
        tryStmt.catches.each |c| { scanBlockForCatchTypes(c.block, podName, result) }
        if (tryStmt.finallyBlock != null)
          scanBlockForCatchTypes(tryStmt.finallyBlock, podName, result)
      }
      else if (stmt.id == StmtId.ifStmt)
      {
        ifStmt := stmt as IfStmt
        scanBlockForCatchTypes(ifStmt.trueBlock, podName, result)
        if (ifStmt.falseBlock != null) scanBlockForCatchTypes(ifStmt.falseBlock, podName, result)
      }
      else if (stmt.id == StmtId.forStmt)
      {
        forStmt := stmt as ForStmt
        if (forStmt.block != null) scanBlockForCatchTypes(forStmt.block, podName, result)
      }
      else if (stmt.id == StmtId.whileStmt)
      {
        whileStmt := stmt as WhileStmt
        scanBlockForCatchTypes(whileStmt.block, podName, result)
      }
      else if (stmt.id == StmtId.switchStmt)
      {
        switchStmt := stmt as SwitchStmt
        switchStmt.cases.each |c| { scanBlockForCatchTypes(c.block, podName, result) }
        if (switchStmt.defaultBlock != null) scanBlockForCatchTypes(switchStmt.defaultBlock, podName, result)
      }
    }
  }

//////////////////////////////////////////////////////////////////////////
// Class
//////////////////////////////////////////////////////////////////////////

  private Void classDef(TypeDef t)
  {
    // class ClassName(Mixin1, Mixin2, BaseClass):
    // Python supports multiple inheritance - include all mixins plus base class
    w("class ${PyUtil.escapeTypeName(t.name)}")
    w("(")

    bases := Str[,]

    // Collect all mixins that aren't inherited by other mixins
    // This prevents Python MRO conflicts like class X(Dict, LibDepend)
    // where LibDepend already extends Dict
    mixinsToInclude := CType[,]
    t.mixins.each |m|
    {
      if (m.qname == "sys::Obj") return  // Skip Obj

      // Check if this mixin is inherited by another mixin in the list
      alreadyInherited := t.mixins.any |other|
      {
        if (other.qname == m.qname) return false  // Skip self
        // Check if 'other' mixin extends 'm'
        return other.mixins.any |mm| { mm.qname == m.qname }
      }

      if (!alreadyInherited)
        mixinsToInclude.add(m)
    }

    // Add filtered mixins
    mixinsToInclude.each |m|
    {
      bases.add(m.name)
    }

    // Add base class if it's not Obj and not already inherited via mixins
    baseAlreadyInherited := t.base != null && !t.base.isObj &&
      mixinsToInclude.any |m| {
        if (m.base?.qname == t.base.qname) return true
        return m.mixins.any |mm| { mm.qname == t.base.qname }
      }

    if (t.base != null && !t.base.isObj && !baseAlreadyInherited)
      bases.add(t.base.name)
    else if (bases.isEmpty)
      bases.add("Obj")

    // Write the bases
    w(bases.join(", "))
    w(")")
    colon

    indent

    // Check if this is an enum type
    if (t.isEnum)
    {
      enumClassDef(t)
    }
    else
    {
      // Static fields (class-level attributes) - must come first
      staticFields(t)

      // Constructor
      ctor(t)

      // Field getters/setters (instance fields only)
      t.fieldDefs.each |f|
      {
        if (f.isStatic) return
        fieldAccessors(f)
      }

      // Methods - track which field accessors we've already emitted
      emittedAccessors := Str:Bool[:]
      t.methodDefs.each |m|
      {
        if (m.isCtor) return
        if (m.isInstanceInit) return
        if (m.isStaticInit) return
        // Allow once helper methods (synthetic but needed) - they end with $Once
        // Allow checkFields$ methods - they validate non-nullable fields were set
        if (m.isSynthetic && !m.name.endsWith("\$Once") && !m.name.startsWith("checkFields\$")) return
        // Skip abstract methods in mixins - they must be implemented by concrete class
        // Python MRO would find the mixin's pass-returning method before the base class implementation
        if (m.isAbstract && t.isMixin) return

        // For field accessors, emit combined getter/setter only once
        if (m.isFieldAccessor)
        {
          fieldName := m.accessorFor.name
          if (emittedAccessors[fieldName] == true) return  // Already emitted
          emittedAccessors[fieldName] = true
          combinedFieldAccessor(m.accessorFor)
          return
        }

        method(m)
      }

      // Generate Python operator methods for Fantom operator methods
      operatorMethods(t)

      // If no methods, add pass
      if (t.methodDefs.isEmpty)
        pass
    }

    unindent
    nl
  }

  ** Generate Python operator methods (__add__, __sub__, etc.)
  ** for Fantom methods with @Operator facet
  private Void operatorMethods(TypeDef t)
  {
    // Map Fantom operator methods to Python special methods
    operatorMap := Str:Str[
      "plus": "__add__",
      "minus": "__sub__",
      "mult": "__mul__",
      "div": "__truediv__",
      "mod": "__mod__",
      "negate": "__neg__",
      "get": "__getitem__",
      "set": "__setitem__"
    ]

    t.methodDefs.each |m|
    {
      // Skip methods without @Operator facet
      hasOperator := m.facets?.any |f| { f.type.qname == "sys::Operator" } ?: false
      if (!hasOperator) return

      pyMethod := operatorMap[m.name]
      if (pyMethod == null) return

      // Generate Python operator method
      // Handle different parameter counts:
      // - 0 params: __neg__ (negate)
      // - 1 param: __add__, __sub__, __getitem__, etc.
      // - 2 params: __setitem__ (set)
      nl
      w("def ${pyMethod}(self")
      if (m.params.size == 1)
      {
        w(", other")
      }
      else if (m.params.size == 2)
      {
        // For __setitem__, Python uses (key, value)
        w(", key, value")
      }
      w(")").colon
      indent
      if (m.params.size == 0)
      {
        w("return self.${escapeName(m.name)}()").eos
      }
      else if (m.params.size == 1)
      {
        w("return self.${escapeName(m.name)}(other)").eos
      }
      else if (m.params.size == 2)
      {
        w("return self.${escapeName(m.name)}(key, value)").eos
      }
      unindent
    }
  }

//////////////////////////////////////////////////////////////////////////
// Enum
//////////////////////////////////////////////////////////////////////////

  ** Generate enum class definition
  private Void enumClassDef(TypeDef t)
  {
    enumFields := t.fieldDefs.findAll |f| { f.enumDef != null }
      .sort |a, b| { a.enumDef.ordinal <=> b.enumDef.ordinal }

    // For enums, only generate static fields for non-enum fields (like once methods)
    // Skip the standard _static_init() for enums since vals()/_make_enum() handles enum initialization
    enumStaticFields(t)

    // Private cache field for vals
    nl
    w("_vals = None").nl

    // Static accessor for each enum value: A(), B(), C()
    enumFields.each |f|
    {
      def := f.enumDef
      nl
      w("@staticmethod").nl
      w("def ${escapeName(def.name)}()").colon
      indent
      w("return ${PyUtil.escapeTypeName(t.name)}.vals().get(${def.ordinal})").eos
      unindent
    }

    // vals() method - creates and caches enum instances
    nl
    w("@staticmethod").nl
    w("def vals()").colon
    indent
    w("if ${PyUtil.escapeTypeName(t.name)}._vals is None").colon
    indent
    // Add sys. prefix only when NOT inside the sys pod
    prefix := t.pod.name != "sys" ? "sys." : ""
    w("${PyUtil.escapeTypeName(t.name)}._vals = ${prefix}List.to_immutable(${prefix}List.from_list([").nl
    indent
    enumFields.each |f, i|
    {
      def := f.enumDef
      w("${PyUtil.escapeTypeName(t.name)}._make_enum(${def.ordinal}, ${def.name.toCode}")
      if (!def.ctorArgs.isEmpty)
      {
        def.ctorArgs.each |arg|
        {
          w(", ")
          PyExprPrinter(this).expr(arg)
        }
      }
      w(")")
      if (i < enumFields.size - 1) w(",")
      nl
    }
    unindent
    w("]))").eos
    unindent
    w("return ${PyUtil.escapeTypeName(t.name)}._vals").eos
    unindent

    // from_str() method
    nl
    w("@staticmethod").nl
    w("def from_str(name, checked=True)").colon
    indent
    w("for v in ${PyUtil.escapeTypeName(t.name)}.vals()").colon
    indent
    w("if v.name() == name").colon
    indent
    w("return v").eos
    unindent
    unindent
    w("if checked").colon
    indent
    // Add sys. prefix only when NOT inside the sys pod
    parseErrPrefix := t.pod.name != "sys" ? "sys." : ""
    w("raise ${parseErrPrefix}ParseErr.make(\"Unknown enum: \" + name)").eos
    unindent
    w("return None").eos
    unindent

    // _make_enum() internal factory
    nl
    w("@staticmethod").nl
    w("def _make_enum(_ordinal, _name")
    // Add ctor params if enum has custom constructor (skip first 2: ordinal, name)
    ctorMethod := t.methodDefs.find |m| { m.isCtor }
    if (ctorMethod != null && ctorMethod.params.size > 2)
    {
      ctorMethod.params[2..-1].each |p|
      {
        w(", ")
        w(escapeName(p.name))
        // Add default value if param has one
        if (p.hasDefault)
        {
          w("=")
          PyExprPrinter(this).expr(p->def)
        }
      }
    }
    w(")").colon
    indent
    w("inst = object.__new__(${PyUtil.escapeTypeName(t.name)})").eos
    w("inst._ordinal = _ordinal").eos
    w("inst._name = _name").eos
    // Initialize custom fields from ctor params (skip first 2: ordinal, name)
    if (ctorMethod != null && ctorMethod.params.size > 2)
    {
      ctorMethod.params[2..-1].each |p|
      {
        w("inst._${escapeName(p.name)} = ${escapeName(p.name)}").eos
      }
    }
    // Run constructor body to compute derived fields
    if (ctorMethod != null && ctorMethod.code != null && !ctorMethod.code.stmts.isEmpty)
    {
      // Need to bind 'self' for the constructor body
      w("self = inst").eos
      stmtPrinter := PyStmtPrinter(this)
      stmtPrinter.scanMethodForClosures(ctorMethod.code)
      ctorMethod.code.stmts.each |s, idx|
      {
        this.m.stmtIndex = idx
        // Skip synthetic return statements
        if (s.id == StmtId.returnStmt)
        {
          ret := s as ReturnStmt
          if (ret.expr == null || ret.isSynthetic) return
        }
        stmtPrinter.stmt(s)
      }
      this.m.clearClosures()
    }
    w("return inst").eos
    unindent

    // ordinal() method
    nl
    w("def ordinal(self)").colon
    indent
    w("return self._ordinal").eos
    unindent

    // name() method
    nl
    w("def name(self)").colon
    indent
    w("return self._name").eos
    unindent

    // to_str() returns the name
    nl
    w("def to_str(self)").colon
    indent
    w("return self._name").eos
    unindent

    // __str__ for Python
    nl
    w("def __str__(self)").colon
    indent
    w("return self._name").eos
    unindent

    // equals - compare by ordinal for enum equality
    // NOTE: Using ordinal comparison because enum values may be stored/retrieved
    // from different contexts (e.g., LogRec._level vs LogLevel.debug())
    nl
    w("def equals(self, other)").colon
    indent
    w("if not isinstance(other, ${PyUtil.escapeTypeName(t.name)})").colon
    indent
    w("return False").eos
    unindent
    w("return self._ordinal == other._ordinal").eos
    unindent

    // compare by ordinal
    nl
    w("def compare(self, other)").colon
    indent
    w("return self._ordinal - other._ordinal").eos
    unindent

    // Python comparison operators
    nl
    w("def __lt__(self, other)").colon
    indent
    w("return self._ordinal < other._ordinal").eos
    unindent

    nl
    w("def __le__(self, other)").colon
    indent
    w("return self._ordinal <= other._ordinal").eos
    unindent

    nl
    w("def __gt__(self, other)").colon
    indent
    w("return self._ordinal > other._ordinal").eos
    unindent

    nl
    w("def __ge__(self, other)").colon
    indent
    w("return self._ordinal >= other._ordinal").eos
    unindent

    nl
    w("def __eq__(self, other)").colon
    indent
    w("if not isinstance(other, ${PyUtil.escapeTypeName(t.name)})").colon
    indent
    w("return False").eos
    unindent
    w("return self._ordinal == other._ordinal").eos
    unindent

    nl
    w("def __hash__(self)").colon
    indent
    w("return hash(self._ordinal)").eos
    unindent

    // Field getters for custom fields (skip enum values and vals field)
    t.fieldDefs.each |f|
    {
      if (f.enumDef != null) return  // Skip enum value fields (A, B, C)
      if (f.name == "vals") return   // Skip vals - we generate our own static vals()
      if (f.isStatic) return         // Skip other static fields
      fieldAccessors(f)
    }

    // Additional methods (like negOrdinal in EnumAbc)
    // Also allows $Once helper methods for once methods on enums
    t.methodDefs.each |m|
    {
      if (m.isCtor) return
      if (m.isInstanceInit) return
      if (m.isStaticInit) return
      // Allow once helper methods (synthetic but needed) - they end with $Once
      // Allow checkFields$ methods - they validate non-nullable fields were set
      if (m.isSynthetic && !m.name.endsWith("\$Once") && !m.name.startsWith("checkFields\$")) return
      if (m.name == "fromStr") return  // Already generated

      method(m)
    }
  }

//////////////////////////////////////////////////////////////////////////
// Constructor
//////////////////////////////////////////////////////////////////////////

  ** Generate Python constructor code from Fantom constructors.
  **
  ** Python Pattern:
  **   - Static factory methods: make(), makeFrom(), etc. (all ctors)
  **   - Single __init__(): uses primary ctor's signature
  **   - Named ctor bodies: _makeFoo_body() for non-primary ctors
  **   - Field init helper: _ctor_init() for named ctors to share field setup
  **
  ** Fantom -> Python mapping:
  **   - `new make(a, b)` -> `make(a, b)` factory + `__init__(self, a, b)`
  **   - `new makeFoo(x)` -> `makeFoo(x)` factory + `_makeFoo_body(self, x)`
  **   - `static new make()` -> `make()` factory only (no __init__ body)
  **   - Constructor chaining (: super, : this) handled in body methods
  **
  private Void ctor(TypeDef t)
  {
    // Find ALL constructors
    ctorMethods := t.methodDefs.findAll |m| { m.isCtor }

    // Separate static ctors (factories) from instance ctors
    // Static ctor: `static new make(...)` - just a factory, body should NOT go in __init__
    // Instance ctor: `new make(...)` - body goes in __init__
    instanceCtors := ctorMethods.findAll |m| { !m.isStatic }
    staticCtors := ctorMethods.findAll |m| { m.isStatic }

    // If no constructors, use a simple default
    if (ctorMethods.isEmpty)
    {
      // Generate static make() factory method with no params
      nl
      w("@staticmethod").nl
      w("def make()").colon
      indent
      w("return ${PyUtil.escapeTypeName(t.name)}()").eos
      unindent

      // Generate __init__ constructor
      // For mixins, use *args, **kwargs to support cooperative multiple inheritance
      nl
      if (t.isMixin)
      {
        w("def __init__(self, *args, **kwargs)").colon
        indent
        w("super().__init__(*args, **kwargs)").eos
      }
      else
      {
        w("def __init__(self)").colon
        indent
        w("super().__init__()").eos
      }
      // Instance field initialization
      t.fieldDefs.each |f|
      {
        if (f.isStatic) return
        fieldInit(f)
      }
      unindent
      nl
      return
    }

    // Find the primary constructor for __init__:
    // - Prefer instance ctor named "make", else first instance ctor
    // - If no instance ctors, use first static ctor but __init__ will have minimal body
    primaryCtor := instanceCtors.find |m| { m.name == "make" } ?: instanceCtors.first
    hasInstanceCtor := primaryCtor != null
    if (primaryCtor == null)
      primaryCtor = staticCtors.find |m| { m.name == "make" } ?: staticCtors.first

    // Generate static factory methods for ALL constructors
    ctorMethods.each |ctorMethod|
    {
      ctorName := escapeName(ctorMethod.name)  // "make", "make_def", etc. (snake_case)
      isStaticFactory := ctorMethod.isStatic  // static new make(...) vs new make(...)

      nl
      w("@staticmethod").nl
      w("def ${ctorName}(")
      ctorMethod.params.each |p, i|
      {
        if (i > 0) w(", ")
        w(escapeName(p.name))
        if (p.hasDefault)
        {
          w("=None")
        }
      }
      w(")")
      colon
      indent

      // For static factories: run the factory body code (they call other ctors internally)
      // For instance ctors: create instance and run body
      if (isStaticFactory)
      {
        // Static factory - run the body code which creates/returns instance
        // The body will call other ctors like makeImpl or makeSegs
        emitDefaultParamChecks(ctorMethod)
        if (ctorMethod.code != null && !ctorMethod.code.stmts.isEmpty)
        {
          // Mark static context
          this.m.inStaticContext = true
          stmtPrinter := PyStmtPrinter(this)
          stmtPrinter.scanMethodForClosures(ctorMethod.code)
          ctorMethod.code.stmts.each |s, idx|
          {
            this.m.stmtIndex = idx
            stmtPrinter.stmt(s)
          }
          this.m.clearClosures()
          this.m.inStaticContext = false
        }
        else
        {
          pass
        }
      }
      else if (ctorName != "make")
      {
        // Named instance constructor (not "make") - create instance and run ctor body
        w("inst = object.__new__(${PyUtil.escapeTypeName(t.name)})").eos

        // Check if this ctor chains to this.make() - if so, skip _ctor_init
        // because __init__() will handle field initialization
        chainsToThisMake := ctorMethod.ctorChain != null &&
          (ctorMethod.ctorChain.target == null || ctorMethod.ctorChain.target.id == ExprId.thisExpr) &&
          ctorMethod.ctorChain.method.name == "make"

        if (!chainsToThisMake)
        {
          w("inst._ctor_init()").eos  // Initialize fields only if not chaining to make()
        }

        // Call the instance body method with params
        w("inst._${ctorName}_body(")
        ctorMethod.params.each |p, i|
        {
          if (i > 0) w(", ")
          w(escapeName(p.name))
        }
        w(")").eos
        w("return inst").eos
      }
      else
      {
        // Primary instance make() just delegates to __init__
        w("return ${PyUtil.escapeTypeName(t.name)}(")
        ctorMethod.params.each |p, i|
        {
          if (i > 0) w(", ")
          w(escapeName(p.name))
        }
        w(")").eos
      }
      unindent
    }

    // Generate instance body methods for named constructors
    ctorMethods.each |ctorMethod|
    {
      if (ctorMethod.name == "make") return  // Primary ctor uses __init__

      nl
      w("def _${escapeName(ctorMethod.name)}_body(self")
      ctorMethod.params.each |p|
      {
        w(", ")
        w(escapeName(p.name))
        if (p.hasDefault)
        {
          w("=None")
        }
      }
      w(")").colon
      indent

      // Emit default parameter value checks at start of body method
      // This ensures parameters like `unit := hr` get their defaults applied
      emitDefaultParamChecks(ctorMethod)

      emittedStmts := false

      // Handle constructor chaining (: this.make(...) or : super(...))
      if (ctorMethod.ctorChain != null)
      {
        chain := ctorMethod.ctorChain
        // Check if chaining to this or super
        isThisChain := chain.target == null || chain.target.id == ExprId.thisExpr
        isSuperChain := chain.target != null && chain.target.id == ExprId.superExpr

        if (isThisChain)
        {
          // this.make(...) - call another constructor on this type
          chainCtorName := chain.method.name
          if (chainCtorName == "make")
          {
            // Call __init__ directly to chain to primary constructor
            w("self.__init__(")
            chain.args.each |arg, i|
            {
              if (i > 0) w(", ")
              PyExprPrinter(this).expr(arg)
            }
            w(")").eos
          }
          else
          {
            // Chain to another named constructor's body
            w("self._${escapeName(chainCtorName)}_body(")
            chain.args.each |arg, i|
            {
              if (i > 0) w(", ")
              PyExprPrinter(this).expr(arg)
            }
            w(")").eos
          }
        }
        else if (isSuperChain)
        {
          // super(...) - call parent constructor with chain arguments
          // This re-calls parent's __init__ with actual arguments to set up parent fields
          chainCtorName := chain.method.name
          if (chainCtorName == "make")
          {
            // Call parent's __init__ with arguments
            w("super().__init__(")
            chain.args.each |arg, i|
            {
              if (i > 0) w(", ")
              PyExprPrinter(this).expr(arg)
            }
            w(")").eos
          }
          else
          {
            // Call parent's named constructor body
            w("super()._${escapeName(chainCtorName)}_body(")
            chain.args.each |arg, i|
            {
              if (i > 0) w(", ")
              PyExprPrinter(this).expr(arg)
            }
            w(")").eos
          }
        }
        emittedStmts = true
      }

      if (ctorMethod.code != null && !ctorMethod.code.stmts.isEmpty)
      {
        stmtPrinter := PyStmtPrinter(this)
        stmtPrinter.scanMethodForClosures(ctorMethod.code)
        ctorMethod.code.stmts.each |s, idx|
        {
          this.m.stmtIndex = idx
          // Skip synthetic return statements
          if (s.id == StmtId.returnStmt)
          {
            ret := s as ReturnStmt
            if (ret.expr == null || ret.isSynthetic) return
          }
          // Skip synthetic instance init calls and enterCtor/exitCtor (field-not-set checks)
          if (s.id == StmtId.expr)
          {
            exprStmt := s as ExprStmt
            if (exprStmt.expr.id == ExprId.call)
            {
              call := exprStmt.expr as CallExpr
              if (call.method.name.contains("\$init\$")) return
              // Skip Fantom's enterCtor/exitCtor field-not-set checking (not needed in Python)
              if (call.method.name == "enterCtor" || call.method.name == "exitCtor") return
            }
          }
          stmtPrinter.stmt(s)
          emittedStmts = true
        }
        this.m.clearClosures()
      }
      if (!emittedStmts)
      {
        pass
      }
      unindent
    }

    // Generate _ctor_init helper for field initialization (used by named ctors)
    // This method ONLY initializes THIS class's fields - it does NOT call parent.
    // Named constructor body methods (like _makeResolved_body) are responsible
    // for calling the appropriate parent constructor with proper arguments.
    if (ctorMethods.size > 1 || (ctorMethods.size == 1 && ctorMethods.first.name != "make"))
    {
      nl
      w("def _ctor_init(self)").colon
      indent

      // Check if parent will have _ctor_init (multiple ctors or named ctors)
      parentHasMultipleCtors := t.base != null && !t.base.isObj && t.base.ctors.size > 1
      parentHasNamedCtors := t.base != null && !t.base.isObj &&
        t.base.ctors.any |ctor| { ctor.name != "make" }
      parentWillHaveCtorInit := parentHasMultipleCtors || parentHasNamedCtors

      hasFieldsToInit := t.fieldDefs.any |f| { !f.isStatic }
      hasInstanceInit := t.methodDefs.any |m| { m.isInstanceInit && m.code != null }

      if (parentWillHaveCtorInit)
      {
        // Parent has _ctor_init, so we can call it to initialize parent fields
        w("super()._ctor_init()").eos
      }
      else if (!hasFieldsToInit && !hasInstanceInit)
      {
        // No parent call, no fields, no instance init - need pass
        pass
      }
      // Otherwise, DO NOT call parent - the named constructor body will handle
      // the parent chain with proper arguments

      // Instance field initialization (THIS class's fields only)
      t.fieldDefs.each |f|
      {
        if (f.isStatic) return
        fieldInit(f)
      }
      // Instance init block
      instanceInitMethod := t.methodDefs.find |m| { m.isInstanceInit }
      if (instanceInitMethod != null && instanceInitMethod.code != null)
      {
        stmtPrinter := PyStmtPrinter(this)
        stmtPrinter.scanMethodForClosures(instanceInitMethod.code)
        instanceInitMethod.code.stmts.each |s, idx|
        {
          this.m.stmtIndex = idx
          stmtPrinter.stmt(s)
        }
        this.m.clearClosures()
      }
      unindent
    }

    // Generate __init__ constructor (uses primary ctor's signature)
    // For mixins, use *args, **kwargs to support cooperative multiple inheritance
    nl
    if (t.isMixin)
    {
      w("def __init__(self, *args, **kwargs)")
    }
    else
    {
      w("def __init__(self")

      // Only emit params if we have an actual instance constructor
      // Static factories (static new) don't define instance constructor params
      if (hasInstanceCtor)
      {
        // In Python, once we emit a default parameter, ALL following params must have defaults
        // Find the first index where we should start emitting defaults:
        // - explicit hasDefault, OR
        // - nullable type AND all following params also have defaults or are nullable
        firstDefaultIdx := primaryCtor.params.size
        for (i := primaryCtor.params.size - 1; i >= 0; i--)
        {
          p := primaryCtor.params[i]
          if (p.hasDefault || p.type.isNullable)
            firstDefaultIdx = i
          else
            break  // Found a required param, stop
        }

        primaryCtor.params.each |p, i|
        {
          w(", ")
          w(escapeName(p.name))
          // Only add =None if at or after firstDefaultIdx
          if (i >= firstDefaultIdx)
          {
            w("=None")
          }
        }
      }
      w(")")
    }
    colon

    indent

    // Emit default parameter value checks at start of constructor body
    // Only do this if we have an actual instance constructor with params
    if (hasInstanceCtor)
      emitDefaultParamChecks(primaryCtor)

    // Call super().__init__() with constructor chain arguments
    // For mixins, pass through *args, **kwargs to support cooperative multiple inheritance
    if (t.isMixin)
    {
      w("super().__init__(*args, **kwargs)").eos
    }
    else
    {
      w("super().__init__(")
      // Only pass chain args to super().__init__() if chain target is super (not this)
      // For this.makeFields(...) chains, the args are for the sibling constructor, not parent
      if (hasInstanceCtor && primaryCtor.ctorChain != null)
      {
        chain := primaryCtor.ctorChain
        isSuperChain := chain.target != null && chain.target.id == ExprId.superExpr
        if (isSuperChain)
        {
          chain.args.each |arg, i|
          {
            if (i > 0) w(", ")
            PyExprPrinter(this).expr(arg)
          }
        }
      }
      w(")").eos
    }

    // Instance field initialization
    t.fieldDefs.each |f|
    {
      if (f.isStatic) return
      fieldInit(f)
    }

    // Instance init block
    instanceInitMethod := t.methodDefs.find |m| { m.isInstanceInit }
    if (instanceInitMethod != null && instanceInitMethod.code != null)
    {
      stmtPrinter := PyStmtPrinter(this)
      stmtPrinter.scanMethodForClosures(instanceInitMethod.code)
      instanceInitMethod.code.stmts.each |s, idx|
      {
        this.m.stmtIndex = idx
        // Skip synthetic return statements (same filtering as primary ctor body)
        if (s.id == StmtId.returnStmt)
        {
          ret := s as ReturnStmt
          if (ret.expr == null || ret.isSynthetic) return
        }
        stmtPrinter.stmt(s)
      }
      this.m.clearClosures()
    }

    // Primary constructor body
    // ONLY emit body if primaryCtor is an instance ctor (not a static factory)
    // Static factories (static new make(...)) should NOT have their body in __init__
    // because they return newly constructed instances, not modify `self`
    if (hasInstanceCtor && primaryCtor.code != null)
    {
      stmtPrinter := PyStmtPrinter(this)
      stmtPrinter.scanMethodForClosures(primaryCtor.code)

      primaryCtor.code.stmts.each |s, idx|
      {
        this.m.stmtIndex = idx
        // Skip synthetic return statements
        if (s.id == StmtId.returnStmt)
        {
          ret := s as ReturnStmt
          if (ret.expr == null || ret.isSynthetic) return
          // Skip return statements that return construction calls (factory pattern)
          // These are static factory returns, not instance initialization
          if (ret.expr.id == ExprId.call || ret.expr.id == ExprId.construction) return
        }
        // Skip synthetic instance init calls and enterCtor/exitCtor (field-not-set checks)
        if (s.id == StmtId.expr)
        {
          exprStmt := s as ExprStmt
          if (exprStmt.expr.id == ExprId.call)
          {
            call := exprStmt.expr as CallExpr
            if (call.method.name.contains("\$init\$")) return
            // Skip Fantom's enterCtor/exitCtor field-not-set checking (not needed in Python)
            if (call.method.name == "enterCtor" || call.method.name == "exitCtor") return
          }
        }
        stmtPrinter.stmt(s)
      }
    }

    // Clear closure state
    this.m.clearClosures()

    unindent
    nl
  }

  private Void fieldInit(FieldDef f)
  {
    w("self._${escapeName(f.name)} = ")
    if (f.init != null)
      PyExprPrinter(this).expr(f.init)
    else
      w(defaultVal(f.type))
    eos
  }

  private Void fieldAccessors(FieldDef f)
  {
    // Skip if field has custom get/set accessors
    // Custom accessors are generated via combinedFieldAccessor() call below
    if (f.hasGet || f.hasSet) return

    name := escapeName(f.name)
    // Return type reflects Fantom's actual type: non-nullable Str -> 'str',
    // nullable Str? -> 'Optional[str]'.  Setter returns the value so both
    // code paths have a matching return type ("set is always just a get too").
    retHint := pyTypeHint(f.type)

    // Generate combined getter/setter: def fieldName(self, _val_=_UNSET) -> T:
    // This is required because PyExprPrinter.assign() uses method call syntax
    // for field assignments on transpiled types: target.fieldName(value)
    nl
    w("def ${name}(self, _val_=_UNSET) -> ${retHint}").colon
    indent
    w("if _val_ is _UNSET").colon
    indent
    w("return self._${name}").eos
    unindent
    w("else").colon
    indent
    w("self._${name} = _val_").eos
    w("return _val_").eos
    unindent
    unindent
  }

  ** Default value for uninitialized fields.
  ** In Fantom:
  ** - Nullable types (?) always default to null
  ** - Non-nullable primitives (Int, Float, Bool) have type defaults (0, 0.0, false)
  ** - Non-nullable reference types (Str, List, etc.) start as null, must be initialized
  private Str defaultVal(CType t)
  {
    // Nullable types always default to None
    if (t.isNullable) return "None"

    sig := t.signature
    // Non-nullable primitives have type-specific defaults
    if (sig == "sys::Bool") return "False"
    if (sig == "sys::Int") return "0"
    if (sig == "sys::Float") return "0.0"

    // Non-nullable reference types (Str, List, etc.) start as None
    // They must be initialized by constructor - Fantom's type system enforces this
    return "None"
  }

  ** Type-specific default for static field getter fallback
  ** Used only when static field getter finds None after _static_init()
  private Str typeDefaultVal(CType t)
  {
    if (t.isNullable) return "None"
    sig := t.signature
    if (sig == "sys::Bool") return "False"
    if (sig == "sys::Int") return "0"
    if (sig == "sys::Float") return "0.0"
    if (sig == "sys::Str") return "\"\""
    return "None"
  }

//////////////////////////////////////////////////////////////////////////
// Static Fields
//////////////////////////////////////////////////////////////////////////

  ** Generate static fields for enum types
  ** Handles once storage fields, regular computed static fields, but skips vals and enum values
  ** since those are handled by the enum-specific code generation
  private Void enumStaticFields(TypeDef t)
  {
    // Collect once storage field names
    onceStorageFieldNames := Str:Bool[:]
    t.methodDefs.each |m|
    {
      if (m.isOnce)
        onceStorageFieldNames["${m.name}\$Store"] = true
    }

    // Find static fields for enums (once storage fields AND regular computed static fields)
    staticFieldDefs := t.fieldDefs.findAll |f|
    {
      if (!f.isStatic) return false
      if (f.enumDef != null) return false  // Skip enum value fields
      if (f.name == "vals") return false   // Skip vals - handled by enum code
      // Include once storage fields
      if (f.isOnce) return true
      if (onceStorageFieldNames.containsKey(f.name)) return true
      // Also include regular static fields (like 'keywords' map)
      if (!f.isSynthetic) return true
      return false
    }
    if (staticFieldDefs.isEmpty) return

    // Check if there's a staticInit method
    staticInitMethod := t.methodDefs.find |m| { m.isStaticInit }

    // Generate class-level storage for each static field
    nl
    staticFieldDefs.each |f|
    {
      isOnceStorage := f.isOnce || onceStorageFieldNames.containsKey(f.name)
      if (isOnceStorage)
        w("_${escapeName(f.name)} = \"_once_\"").nl
      else
        w("_${escapeName(f.name)} = None").nl
    }

    // Generate static getter for each static field
    staticFieldDefs.each |f|
    {
      isOnceStorage := f.isOnce || onceStorageFieldNames.containsKey(f.name)
      staticFieldGetter(t, f, staticInitMethod != null && !isOnceStorage, isOnceStorage)
    }

    // Generate _static_init() method if there's a staticInit block or fields need init
    if (staticInitMethod != null || staticFieldDefs.any |f| { f.init != null && !f.isOnce && !onceStorageFieldNames.containsKey(f.name) })
    {
      enumStaticInit(t, staticInitMethod, staticFieldDefs, onceStorageFieldNames)
    }
  }

  ** Generate _static_init() for enum types - handles computed static fields
  private Void enumStaticInit(TypeDef t, MethodDef? staticInitMethod, FieldDef[] staticFieldDefs, Str:Bool onceStorageFieldNames)
  {
    typeName := PyUtil.escapeTypeName(t.name)

    nl
    w("@staticmethod").nl
    w("def _static_init()").colon
    indent

    // Add re-entry guard
    w("if hasattr(${typeName}, '_static_init_in_progress') and ${typeName}._static_init_in_progress").colon
    indent
    w("return").eos
    unindent
    w("${typeName}._static_init_in_progress = True").eos

    m.inStaticContext = true

    // Collect enum field names for filtering
    enumFieldNames := Str:Bool[:]
    t.fieldDefs.each |f|
    {
      if (f.enumDef != null)
        enumFieldNames[f.name] = true
    }

    if (staticInitMethod != null && staticInitMethod.code != null)
    {
      stmtPrinter := PyStmtPrinter(this)
      stmtPrinter.scanMethodForClosures(staticInitMethod.code)
      staticInitMethod.code.stmts.each |s, idx|
      {
        this.m.stmtIndex = idx
        // Skip synthetic return
        if (s.id == StmtId.returnStmt)
        {
          ret := s as ReturnStmt
          if (ret.expr == null) return
        }
        // Skip enum value field assignments
        if (isEnumFieldAssignment(s, enumFieldNames))
          return
        // Skip once field assignments (they use sentinel pattern)
        if (isOnceFieldAssignment(s, onceStorageFieldNames))
          return
        stmtPrinter.stmt(s)
      }
      this.m.clearClosures()
    }
    else
    {
      // No static block - initialize fields with inline initializers
      staticFieldDefs.each |f|
      {
        if (f.init == null) return
        if (f.isOnce || onceStorageFieldNames.containsKey(f.name)) return
        name := escapeName(f.name)
        w("if ${typeName}._${name} is None").colon
        indent
        w("${typeName}._${name} = ")
        PyExprPrinter(this).expr(f.init)
        eos
        unindent
      }
    }

    w("${typeName}._static_init_in_progress = False").eos
    m.inStaticContext = false

    unindent
  }

  ** Check if a statement assigns to a once storage field
  private Bool isOnceFieldAssignment(Stmt s, Str:Bool onceFieldNames)
  {
    if (s.id != StmtId.expr) return false
    exprStmt := s as ExprStmt
    if (exprStmt.expr.id != ExprId.assign) return false

    assignExpr := exprStmt.expr as BinaryExpr
    if (assignExpr.lhs.id != ExprId.field) return false

    fieldExpr := assignExpr.lhs as FieldExpr
    if (!fieldExpr.field.isStatic) return false

    return onceFieldNames.containsKey(fieldExpr.field.name)
  }

  ** Generate static fields with class-level storage and lazy-init getters
  ** Follows the JavaScript transpiler pattern from JsType.writeStaticField()
  private Void staticFields(TypeDef t)
  {
    // Collect names of once storage fields from once methods
    // When Fantom compiles a `once` method, it creates:
    //   1. A storage field: methodName$Store (synthetic)
    //   2. A helper method: methodName$Once (synthetic, contains original body)
    //   3. The original method modified to check storage and call helper
    // We identify once storage fields by finding methods with isOnce=true
    onceStorageFieldNames := Str:Bool[:]
    t.methodDefs.each |m|
    {
      if (m.isOnce)
        onceStorageFieldNames["${m.name}\$Store"] = true
    }

    // Find all static fields:
    // - Non-synthetic fields (normal static fields)
    // - Synthetic fields that are once storage (identified by method analysis above)
    // - Fields with isOnce flag set (compiler may also set this)
    staticFieldDefs := t.fieldDefs.findAll |f|
    {
      if (!f.isStatic) return false
      if (f.enumDef != null) return false  // Skip enum value fields - handled by vals()/_make_enum()
      if (!f.isSynthetic) return true  // Normal static field
      if (f.isOnce) return true         // Compiler marked as once
      if (onceStorageFieldNames.containsKey(f.name)) return true  // Backing storage for once method
      return false
    }
    if (staticFieldDefs.isEmpty) return

    // Check if there's a staticInit method
    staticInitMethod := t.methodDefs.find |m| { m.isStaticInit }

    // Generate class-level storage for each static field
    nl
    staticFieldDefs.each |f|
    {
      // Once fields use "_once_" as sentinel value, regular fields use None
      isOnceStorage := f.isOnce || onceStorageFieldNames.containsKey(f.name)
      if (isOnceStorage)
        w("_${escapeName(f.name)} = \"_once_\"").nl
      else
        w("_${escapeName(f.name)} = None").nl
    }

    // Generate static getter for each static field
    staticFieldDefs.each |f|
    {
      // Determine if this is a once storage field (synthetic backing for once method)
      isOnceStorage := f.isOnce || onceStorageFieldNames.containsKey(f.name)
      staticFieldGetter(t, f, staticInitMethod != null, isOnceStorage)
    }

    // Generate _static_init() method if there's a staticInit block or fields need init
    if (staticInitMethod != null || staticFieldDefs.any |f| { f.init != null })
    {
      staticInit(t, staticInitMethod, staticFieldDefs)
    }
  }

  ** Generate static getter method for a static field
  ** isOnceStorage: true if this field is backing storage for a once method
  private Void staticFieldGetter(TypeDef t, FieldDef f, Bool hasStaticInit, Bool isOnceStorage)
  {
    name := escapeName(f.name)
    typeName := PyUtil.escapeTypeName(t.name)

    nl
    w("@staticmethod").nl
    w("def ${name}()").colon
    indent

    // Special handling for 'once' fields (either compiler-marked or identified as once storage)
    // Once fields use "_once_" as sentinel and call the $Once helper method
    if (isOnceStorage)
    {
      // The field name is like "specRef$Store", helper method is "specRef$Once"
      // We need to extract the base name and generate the helper call
      // Field name: specRef_Store (escaped from specRef$Store)
      // Helper method: specRef_Once (escaped from specRef$Once)
      baseName := f.name
      if (baseName.endsWith("\$Store"))
        baseName = baseName[0..<-6]  // Remove "$Store" suffix
      helperName := escapeName(baseName + "\$Once")

      w("if ${typeName}._${name} == \"_once_\"").colon
      indent
      w("${typeName}._${name} = ${typeName}.${helperName}()").eos
      unindent
      w("return ${typeName}._${name}").eos
    }
    else
    {
      // Regular static field - check if uninitialized, then initialize
      w("if ${typeName}._${name} is None").colon
      indent
      if (hasStaticInit || f.init != null)
      {
        w("${typeName}._static_init()").eos
      }
      // If still None after static init, use type-specific default value
      w("if ${typeName}._${name} is None").colon
      indent
      w("${typeName}._${name} = ${typeDefaultVal(f.type)}").eos
      unindent
      unindent

      w("return ${typeName}._${name}").eos
    }
    unindent
  }

  ** Generate _static_init() method that initializes all static fields
  ** Follows Fantom's source order: static blocks run before fields declared after them
  private Void staticInit(TypeDef t, MethodDef? staticInitMethod, FieldDef[] staticFieldDefs)
  {
    typeName := PyUtil.escapeTypeName(t.name)

    nl
    w("@staticmethod").nl
    w("def _static_init()").colon
    indent

    // Add re-entry guard to prevent infinite recursion
    // This handles circular dependencies between static fields
    w("if hasattr(${typeName}, '_static_init_in_progress') and ${typeName}._static_init_in_progress").colon
    indent
    w("return").eos
    unindent
    w("${typeName}._static_init_in_progress = True").eos

    // Mark that we're in a static context (no 'self' available)
    m.inStaticContext = true

    // Collect enum field names for filtering (only for enum types)
    enumFieldNames := Str:Bool[:]
    if (t.isEnum)
    {
      t.fieldDefs.each |f|
      {
        if (f.enumDef != null)
          enumFieldNames[f.name] = true
      }
    }

    // If there's a static init method, it contains EVERYTHING (Fantom compiler combines
    // all static initialization into one method). Just emit it, skipping the final return
    // and enum value assignments (which are handled by vals()/_make_enum()).
    if (staticInitMethod != null && staticInitMethod.code != null)
    {
      stmtPrinter := PyStmtPrinter(this)
      stmtPrinter.scanMethodForClosures(staticInitMethod.code)
      staticInitMethod.code.stmts.each |s, idx|
      {
        this.m.stmtIndex = idx
        // Skip synthetic return at end - we'll handle cleanup after
        if (s.id == StmtId.returnStmt)
        {
          ret := s as ReturnStmt
          if (ret.expr == null) return  // Skip void return
        }
        // Skip enum value field assignments - they're handled by vals()/_make_enum()
        if (t.isEnum && isEnumFieldAssignment(s, enumFieldNames))
          return
        stmtPrinter.stmt(s)
      }
      this.m.clearClosures()
    }
    else
    {
      // No static block - just initialize fields with inline initializers
      staticFieldDefs.each |f|
      {
        if (f.init == null) return
        name := escapeName(f.name)
        w("if ${typeName}._${name} is None").colon
        indent
        w("${typeName}._${name} = ")
        PyExprPrinter(this).expr(f.init)
        eos
        unindent
      }
    }

    // Clear the re-entry guard
    w("${typeName}._static_init_in_progress = False").eos

    // Reset static context flag
    m.inStaticContext = false

    unindent
  }

  ** Generate combined getter/setter method for fields with custom accessors
  ** In Python, we combine them into one method with optional parameter
  private Void combinedFieldAccessor(FieldDef f)
  {
    name := escapeName(f.name)
    // Return type reflects Fantom's actual type.  Setter returns the value
    // so both code paths have a matching return type.
    retHint := pyTypeHint(f.type)

    // Generate: def fieldName(self, _val_=_UNSET) -> T:
    //   if _val_ is _UNSET:
    //     # getter body
    //   else:
    //     # setter body (returns _val_)
    nl
    w("def ${name}(self, _val_=_UNSET) -> ${retHint}").colon
    indent
    nl

    w("if _val_ is _UNSET").colon
    indent
    // Getter body
    if (f.get != null && f.get.code != null)
    {
      stmtPrinter := PyStmtPrinter(this)
      stmtPrinter.scanMethodForClosures(f.get.code)
      f.get.code.stmts.each |s, idx|
      {
        this.m.stmtIndex = idx
        stmtPrinter.stmt(s)
      }
      this.m.clearClosures()
    }
    else
    {
      w("return self._${name}").eos
    }
    unindent

    w("else").colon
    indent
    // Setter body - need to replace 'it' param with '_val_'
    if (f.set != null && f.set.code != null)
    {
      // Map 'it' to '_val_' for the setter body
      w("it = _val_").eos
      stmtPrinter := PyStmtPrinter(this)
      stmtPrinter.scanMethodForClosures(f.set.code)
      f.set.code.stmts.each |s, idx|
      {
        this.m.stmtIndex = idx
        stmtPrinter.stmt(s)
      }
      this.m.clearClosures()
    }
    else
    {
      w("self._${name} = _val_").eos
    }
    w("return _val_").eos
    unindent

    unindent
  }

//////////////////////////////////////////////////////////////////////////
// Methods
//////////////////////////////////////////////////////////////////////////

  private Void method(MethodDef m)
  {
    this.m.curMethod = m

    // Set static context flag for static methods
    // This ensures calls like self.make() become ClassName.make()
    if (m.isStatic)
      this.m.inStaticContext = true

    nl

    // Static decorator
    if (m.isStatic)
      w("@staticmethod").nl

    // def method_name(self, params...) -> ReturnType:
    w("def ${escapeName(m.name)}(")
    if (!m.isStatic) w("self")

    m.params.each |p, i|
    {
      if (i > 0 || !m.isStatic) w(", ")
      w(escapeName(p.name))
      w(": ${pyTypeHint(p.type)}")  // Type hint for parameter
      if (p.hasDefault)
      {
        w(" = None")  // Default params simplified for bootstrap
      }
    }
    w(") -> ${pyTypeHint(m.returns)}")  // Return type hint
    colon

    // Method body
    if (m.code == null || m.code.stmts.isEmpty)
    {
      indent
      // Even empty methods need default parameter handling
      // Count how many default checks will actually be emitted
      // Must match the logic in emitDefaultParamChecks
      paramNames := Str[,]
      m.params.each |p| { paramNames.add(p.name) }
      checksEmitted := m.params.any |p|
      {
        if (!p.hasDefault) return false
        defExpr := p->def as Expr
        isNullDefault := defExpr != null && defExpr.id == ExprId.nullLiteral
        // Skip nullable params with non-null defaults unless they reference other params
        if (p.type.isNullable && !isNullDefault && !exprReferencesParams(defExpr, paramNames))
          return false
        return true
      }
      emitDefaultParamChecks(m)
      if (!checksEmitted)
        pass
      unindent
    }
    else
    {
      indent

      // Emit default parameter value checks at start of method body
      // This follows the JavaScript transpiler pattern from JsType.doWriteMethod()
      emitDefaultParamChecks(m)

      // Scan method for closures to track usage
      stmtPrinter := PyStmtPrinter(this)
      stmtPrinter.scanMethodForClosures(m.code)

      // Emit statements (closures emitted lazily)
      m.code.stmts.each |s, idx|
      {
        this.m.stmtIndex = idx
        stmtPrinter.stmt(s)
      }

      unindent
    }

    // Clear closure state for next method
    this.m.clearClosures()

    // NOTE: pyMain is now called from type() method after class ends
    // to ensure if __name__ block is at module level, not inside class

    // Reset static context flag
    if (m.isStatic)
      this.m.inStaticContext = false

    this.m.curMethod = null
  }

  ** Emit default parameter value checks at start of method body
  ** Follows JS transpiler pattern: if (param === undefined) param = defaultExpr;
  ** For Python: if param is None: param = defaultExpr
  **
  ** IMPORTANT: For nullable params (Type?) with non-null defaults, we ONLY emit the check
  ** if the default expression references another parameter (like `val.typeof`).
  ** This preserves the "passing null" semantic for methods that use null to mean "no value"
  ** (e.g., Duration? timeout := 30sec where null means no timeout).
  private Void emitDefaultParamChecks(MethodDef m)
  {
    // Collect param names for reference checking
    paramNames := Str[,]
    m.params.each |p| { paramNames.add(p.name) }

    m.params.each |p|
    {
      if (!p.hasDefault) return

      defExpr := p->def as Expr
      isNullDefault := defExpr != null && defExpr.id == ExprId.nullLiteral

      // For nullable params with non-null defaults, only emit check if default
      // references another param (like val.typeof). Otherwise, skip to preserve
      // the "passing null means null" semantic.
      if (p.type.isNullable && !isNullDefault)
      {
        if (!exprReferencesParams(defExpr, paramNames))
          return  // Skip - let body code handle null
      }

      name := escapeName(p.name)

      // Generate: if param is None: param = defaultValue
      w("if ${name} is None").colon
      indent
      w("${name} = ")
      // p.def_ is the default value expression - transpile it
      PyExprPrinter(this).expr(p->def)
      eos
      unindent
    }
  }

  ** Check if an expression references any of the given parameter names
  ** Used to detect defaults like `val.typeof` that depend on other params
  private Bool exprReferencesParams(Expr? e, Str[] paramNames)
  {
    if (e == null) return false

    // Check if this is a local variable reference to a param
    if (e.id == ExprId.localVar)
    {
      localVar := e as LocalVarExpr
      return paramNames.contains(localVar.var.name)
    }

    // Check call target and args
    if (e.id == ExprId.call)
    {
      call := e as CallExpr
      if (call.target != null && exprReferencesParams(call.target, paramNames))
        return true
      return call.args.any |arg| { exprReferencesParams(arg, paramNames) }
    }

    // Check binary expr operands
    if (e is BinaryExpr)
    {
      bin := e as BinaryExpr
      return exprReferencesParams(bin.lhs, paramNames) || exprReferencesParams(bin.rhs, paramNames)
    }

    // Check unary expr
    if (e is UnaryExpr)
    {
      unary := e as UnaryExpr
      return exprReferencesParams(unary.operand, paramNames)
    }

    // Check ternary
    if (e is TernaryExpr)
    {
      ternary := e as TernaryExpr
      return exprReferencesParams(ternary.condition, paramNames) ||
             exprReferencesParams(ternary.trueExpr, paramNames) ||
             exprReferencesParams(ternary.falseExpr, paramNames)
    }

    // Check shortcut expr
    if (e is ShortcutExpr)
    {
      shortcut := e as ShortcutExpr
      if (exprReferencesParams(shortcut.target, paramNames))
        return true
      return shortcut.args.any |arg| { exprReferencesParams(arg, paramNames) }
    }

    // Check coerce/type check
    if (e.id == ExprId.coerce || e.id == ExprId.isExpr || e.id == ExprId.asExpr)
    {
      typeCheck := e as TypeCheckExpr
      return exprReferencesParams(typeCheck.target, paramNames)
    }

    return false
  }

  ** Check if this is a main(Str[] args) method
  private Bool isMain(MethodDef m)
  {
    m.name == "main" && m.params.size == 1 && m.params[0].type.isList
  }

  ** Generate Python main block
  private Void pyMain(MethodDef m)
  {
    nl
    nl
    w("if __name__ == \"__main__\":").nl
    indent
    typeName := PyUtil.escapeTypeName(m.parent.name)
    w("import sys as sys_mod").nl
    w("from fan.sys.List import List").nl
    w("args = List.from_literal(sys_mod.argv[1:], 'sys::Str')").nl
    w("exit_code = ${typeName}.main(args)").nl
    w("sys_mod.exit(exit_code if exit_code is not None else 0)").nl
    unindent
  }

//////////////////////////////////////////////////////////////////////////
// Type Metadata (Reflection)
//////////////////////////////////////////////////////////////////////////

  ** Generate type metadata registration for reflection
  ** This is similar to how JsPod.writeTypeInfo() works for JavaScript
  private Void typeMetadata(TypeDef t)
  {
    // Skip synthetic types
    if (t.isSynthetic) return

    // Check if we have any slots to register
    hasSlots := t.fieldDefs.any |f| { !f.isSynthetic } ||
                t.methodDefs.any |m| { !m.isSynthetic && !m.isInstanceInit && !m.isStaticInit }

    // Always need to emit tf_() for type-level metadata (facets, mixins, base type)
    // even if there are no slots (e.g., mixins with only inherited members)
    hasFacets := t.facets != null && !t.facets.isEmpty
    hasMixins := !t.mixins.isEmpty && t.mixins.any |m| { m.qname != "sys::Obj" }
    hasBase := t.base != null && !t.base.isObj

    // Skip only if there's nothing to register
    if (!hasSlots && !hasFacets && !hasMixins && !hasBase) return

    nl
    w("# Type metadata registration for reflection").nl
    w("from fan.sys.Param import Param").nl
    w("from fan.sys.Slot import FConst").nl
    // For sys pod types, Type is already imported directly (no sys. prefix)
    // For other pods, use sys.Type.find() via namespace import
    if (t.pod.name == "sys")
      w("_t = Type.find('${t.qname}')").nl
    else
      w("_t = sys.Type.find('${t.qname}')").nl

    // Calculate type flags
    typeFlags := typeFlags(t)

    // Build mixin list
    mixinList := Str[,]
    t.mixins.each |m|
    {
      if (m.qname != "sys::Obj")
        mixinList.add("'${m.qname}'")
    }
    mixinsStr := "[" + mixinList.join(", ") + "]"

    // Register type-level facets with flags, mixins, and base type
    typeFacets := facetDict(t.facets)
    // Enums implicitly have @Serializable{simple=true}
    if (t.isEnum)
    {
      if (typeFacets == "{}")
        typeFacets = "{'sys::Serializable': {'simple': True}}"
      else if (!typeFacets.contains("sys::Serializable"))
        typeFacets = typeFacets[0..-2] + ", 'sys::Serializable': {'simple': True}}"
    }
    // Determine base type (non-Obj)
    baseStr := "None"
    if (t.base != null && !t.base.isObj)
      baseStr = "'${t.base.qname}'"
    // Always emit tf_() with flags, mixins, and base
    w("_t.tf_(${typeFacets}, ${typeFlags}, ${mixinsStr}, ${baseStr})").nl

    // Register fields (including enum value fields)
    t.fieldDefs.each |f|
    {
      if (f.isSynthetic) return

      flags := fieldFlags(f)
      typeSig := PyUtil.sanitizeJavaFfi(f.type.signature)
      fieldFacets := "{}"

      // Enum value fields get special flag handling and may have facets
      if (f.enumDef != null)
      {
        // Enum values are public static const using canonical FConst values
        enumFlags := FConst.Public.or(FConst.Static).or(FConst.Const).or(FConst.Enum)
        fieldFacets = facetDict(f.enumDef.facets)
        // Use original Fantom name (f.name) for enum fields - NOT escapeName()
        // Enum field names like "A", "B", "C" must stay uppercase for reflection
        // Field.name() should return "A" not "a"
        w("_t.af_('${f.name}', ${enumFlags}, '${typeSig}', ${fieldFacets})").nl
      }
      else
      {
        fieldFacets = facetDict(f.facets)
        setterFlags := setterFlags(f)
        // Use escapeName() for regular fields - converts to snake_case to match Python storage
        // The Python code stores fields as _const_x not _constX
        // Only emit setter flags if they differ from field flags
        if (setterFlags != flags)
          w("_t.af_('${escapeName(f.name)}', ${flags}, '${typeSig}', ${fieldFacets}, ${setterFlags})").nl
        else
          w("_t.af_('${escapeName(f.name)}', ${flags}, '${typeSig}', ${fieldFacets})").nl
      }
    }

    // Register methods
    t.methodDefs.each |m|
    {
      if (m.isSynthetic) return
      if (m.isInstanceInit) return
      if (m.isStaticInit) return
      if (m.isFieldAccessor) return

      flags := methodFlags(m)
      retSig := PyUtil.sanitizeJavaFfi(m.returns.signature)
      methodFacets := facetDict(m.facets)

      // Build params list
      // For sys pod types, Type is already imported directly
      // For other pods, use sys.Type.find()
      typeFind := (t.pod.name == "sys") ? "Type.find" : "sys.Type.find"
      if (m.params.isEmpty)
      {
        w("_t.am_('${m.name}', ${flags}, '${retSig}', [], ${methodFacets})").nl
      }
      else
      {
        w("_t.am_('${m.name}', ${flags}, '${retSig}', [")
        m.params.each |p, i|
        {
          if (i > 0) w(", ")
          pType := PyUtil.sanitizeJavaFfi(p.type.signature)
          hasDefault := p.hasDefault ? "True" : "False"
          w("Param('${escapeName(p.name)}', ${typeFind}('${pType}'), ${hasDefault})")
        }
        w("], ${methodFacets})").nl
      }
    }

    // Register implicit default constructor if no explicit (non-synthetic) ctors defined
    // The Fantom compiler adds a synthetic default ctor to methodDefs, so we check for non-synthetic
    // Types without explicit constructors get an implicit make() that needs reflection registration
    explicitCtors := t.methodDefs.findAll |m| { m.isCtor && !m.isSynthetic }
    if (explicitCtors.isEmpty && !t.isEnum && !t.isMixin)
    {
      // Implicit make() is public static constructor returning This
      implicitCtorFlags := FConst.Public.or(FConst.Ctor).or(FConst.Static)
      w("_t.am_('make', ${implicitCtorFlags}, '${t.qname}', [], {})").nl
    }
  }

  ** Serialize facets to Python dict format: {'sys::Serializable': {'simple': True}}
  private Str facetDict(FacetDef[]? facets)
  {
    if (facets == null || facets.isEmpty) return "{}"

    s := StrBuf()
    s.addChar('{')
    facets.each |f, i|
    {
      if (i > 0) s.add(", ")
      s.addChar('\'').add(f.type.qname).add("': ")

      // Build the facet value dict
      if (f.names.isEmpty)
      {
        s.add("{}")
      }
      else
      {
        s.addChar('{')
        f.names.each |name, j|
        {
          if (j > 0) s.add(", ")
          s.addChar('\'').add(name).add("': ")
          // Serialize the value - convert to Python literal
          val := f.vals[j]
          s.add(exprToPython(val))
        }
        s.addChar('}')
      }
    }
    s.addChar('}')
    return s.toStr
  }

  ** Convert a Fantom expression to a Python literal string
  private Str exprToPython(Expr e)
  {
    if (e is LiteralExpr)
    {
      lit := e as LiteralExpr
      val := lit.val
      if (val == null) return "None"
      if (val is Bool) return val == true ? "True" : "False"
      if (val is Int) return val.toStr
      if (val is Float) return val.toStr
      if (val is Str) return val.toStr.toCode
      return val.toStr.toCode
    }
    // Fallback - use Fantom's serialization
    return e.serialize.toCode
  }

  ** Calculate field flags - uses canonical FConst values from compiler/fan/fcode/FConst.fan
  private Int fieldFlags(FieldDef f)
  {
    flags := 0
    if (f.isPublic) flags = flags.or(FConst.Public)
    if (f.isPrivate) flags = flags.or(FConst.Private)
    if (f.isProtected) flags = flags.or(FConst.Protected)
    if (f.isInternal) flags = flags.or(FConst.Internal)
    if (f.isStatic) flags = flags.or(FConst.Static)
    if (f.isVirtual) flags = flags.or(FConst.Virtual)
    if (f.isOverride) flags = flags.or(FConst.Override)
    if (f.isConst) flags = flags.or(FConst.Const)
    return flags
  }

  ** Calculate setter-specific flags - uses canonical FConst values
  ** For fields like "Int x { private set }", the setter has different visibility
  ** than the field itself. Returns setter flags if f.set exists, otherwise field flags.
  private Int setterFlags(FieldDef f)
  {
    // If field has no setter accessor method, use field flags
    if (f.set == null) return fieldFlags(f)

    // Use the setter's flags directly - FConst values from compiler
    setFlags := f.set.flags

    // Check setter's protection using canonical FConst values
    isSetterPublic := setFlags.and(FConst.Public) != 0
    isSetterPrivate := setFlags.and(FConst.Private) != 0
    isSetterProtected := setFlags.and(FConst.Protected) != 0
    isSetterInternal := setFlags.and(FConst.Internal) != 0

    // If setter has no protection flags, inherit from field
    if (!isSetterPublic && !isSetterPrivate && !isSetterProtected && !isSetterInternal)
      return fieldFlags(f)

    // Build output flags using canonical FConst values
    flags := 0
    if (isSetterPublic) flags = flags.or(FConst.Public)
    if (isSetterPrivate) flags = flags.or(FConst.Private)
    if (isSetterProtected) flags = flags.or(FConst.Protected)
    if (isSetterInternal) flags = flags.or(FConst.Internal)

    // Non-protection flags from field
    if (f.isStatic) flags = flags.or(FConst.Static)
    if (f.isVirtual) flags = flags.or(FConst.Virtual)
    if (f.isOverride) flags = flags.or(FConst.Override)
    if (f.isConst) flags = flags.or(FConst.Const)

    return flags
  }

  ** Calculate method flags - uses canonical FConst values from compiler/fan/fcode/FConst.fan
  private Int methodFlags(MethodDef m)
  {
    flags := 0
    if (m.isPublic) flags = flags.or(FConst.Public)
    if (m.isPrivate) flags = flags.or(FConst.Private)
    if (m.isProtected) flags = flags.or(FConst.Protected)
    if (m.isInternal) flags = flags.or(FConst.Internal)
    if (m.isCtor) flags = flags.or(FConst.Ctor)
    if (m.isStatic) flags = flags.or(FConst.Static)
    if (m.isVirtual) flags = flags.or(FConst.Virtual)
    if (m.isAbstract) flags = flags.or(FConst.Abstract)
    if (m.isOverride) flags = flags.or(FConst.Override)
    return flags
  }

  ** Calculate type flags - uses canonical FConst values from compiler/fan/fcode/FConst.fan
  private Int typeFlags(TypeDef t)
  {
    flags := 0
    if (t.isPublic) flags = flags.or(FConst.Public)
    if (t.isInternal) flags = flags.or(FConst.Internal)
    if (t.isAbstract) flags = flags.or(FConst.Abstract)
    if (t.isConst) flags = flags.or(FConst.Const)
    if (t.isFinal) flags = flags.or(FConst.Final)
    if (t.isMixin) flags = flags.or(FConst.Mixin)
    if (t.isEnum) flags = flags.or(FConst.Enum)
    if (t.isFacet) flags = flags.or(FConst.Facet)
    return flags
  }

  ** Check if a statement assigns to an enum value field
  ** Used to filter out enum value initialization from _static_init() since
  ** enum values are handled by vals()/_make_enum() instead
  private Bool isEnumFieldAssignment(Stmt s, Str:Bool enumFieldNames)
  {
    // Check for expression statement with assignment
    if (s.id != StmtId.expr) return false
    exprStmt := s as ExprStmt
    if (exprStmt.expr.id != ExprId.assign) return false

    // Check if LHS is a field reference
    assignExpr := exprStmt.expr as BinaryExpr
    if (assignExpr.lhs.id != ExprId.field) return false

    fieldExpr := assignExpr.lhs as FieldExpr
    if (!fieldExpr.field.isStatic) return false

    // Check if it's an enum field
    return enumFieldNames.containsKey(fieldExpr.field.name)
  }

//////////////////////////////////////////////////////////////////////////
// Python Type Hints
//////////////////////////////////////////////////////////////////////////

  ** Convert Fantom type to Python type hint string
  ** Returns a forward-reference string in quotes like 'Optional[Unit]'
  ** All type hints use forward references (strings) to avoid import order issues
  Str pyTypeHint(CType t)
  {
    // Build the type hint string without quotes, then wrap in quotes at the end
    inner := pyTypeHintInner(t)
    // None is a special case - don't quote it
    if (inner == "None") return "None"
    return "'${inner}'"
  }

  ** Inner type hint builder - returns unquoted type string
  private Str pyTypeHintInner(CType t)
  {
    // Handle nullable types -> Optional[T]
    if (t.isNullable)
    {
      inner := pyTypeHintInner(t.toNonNullable)
      return "Optional[${inner}]"
    }

    sig := t.signature

    // Map Fantom primitives to Python built-in types
    if (sig == "sys::Bool") return "bool"
    if (sig == "sys::Int") return "int"
    if (sig == "sys::Float") return "float"
    if (sig == "sys::Str") return "str"
    if (sig == "sys::Void") return "None"
    if (sig == "sys::Obj") return "Obj"
    if (sig == "sys::This") return "Self"  // Python 3.11+ Self type

    // Handle List[T] - sys::Obj?[] -> List[Obj]
    if (t.isList)
    {
      // Get the value type (V in List<V>)
      listType := t as ListType
      if (listType != null)
      {
        inner := pyTypeHintInner(listType.v)
        return "List[${inner}]"
      }
      return "List"
    }

    // Handle Map[K,V] - [Str:Int] -> Dict[str, int]
    if (t.isMap)
    {
      mapType := t as MapType
      if (mapType != null)
      {
        k := pyTypeHintInner(mapType.k)
        v := pyTypeHintInner(mapType.v)
        return "Dict[${k}, ${v}]"
      }
      return "Dict"
    }

    // Handle Func types -> Callable
    if (t.isFunc)
    {
      funcType := t as FuncType
      if (funcType != null)
      {
        // Build Callable[[Param1, Param2], ReturnType]
        params := StrBuf()
        params.addChar('[')
        funcType.params.each |p, i|
        {
          if (i > 0) params.add(", ")
          params.add(pyTypeHintInner(p))
        }
        params.addChar(']')
        retType := pyTypeHintInner(funcType.returns)
        return "Callable[${params.toStr}, ${retType}]"
      }
      return "Callable"
    }

    // Default: use simple class name
    return t.name
  }

}
