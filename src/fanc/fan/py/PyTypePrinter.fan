//
// Copyright (c) 2025, Brian Frank and Andy Frank
// Licensed under the Academic Free License version 3.0
//
// History:
//   Dec 2025  Creation
//

using compiler

**
** Python type/class printer
**
class PyTypePrinter : PyPrinter
{
  new make(OutStream out) : super(out) {}

  ** Print a complete type definition
  Void type(TypeDef t)
  {
    m.curType = t

    // File header
    header(t)

    // Imports
    imports(t)

    // Class definition
    classDef(t)

    // Type metadata registration (for reflection)
    typeMetadata(t)

    m.curType = null
  }

//////////////////////////////////////////////////////////////////////////
// Header
//////////////////////////////////////////////////////////////////////////

  private Void header(TypeDef t)
  {
    w("#").nl
    w("# ${t.qname}").nl
    w("# Auto-generated by fanc py - do not edit").nl
    w("#").nl
    nl
  }

//////////////////////////////////////////////////////////////////////////
// Imports
//////////////////////////////////////////////////////////////////////////

  private Void imports(TypeDef t)
  {
    // Always import sys module for ObjUtil, etc.
    // Use fan.sys namespace to avoid Python's built-in sys module conflict
    w("import sys as sys_module").nl
    w("sys_module.path.insert(0, '.')").nl
    nl

    // Import base class (but skip if this IS Obj - no self-import)
    if (t.qname != "sys::Obj")
    {
      // Always import Obj - needed for static methods like Obj.echo()
      w("from fan.sys.Obj import Obj").nl

      // Also import non-Obj base class if needed
      if (t.base != null && !t.base.isObj)
      {
        podPath := PyUtil.podImport(t.base.pod.name)
        w("from ${podPath}.${t.base.name} import ${t.base.name}").nl
      }
    }

    // Core sys utilities - always needed for runtime
    w("from fan.sys.ObjUtil import ObjUtil").nl
    w("from fan.sys import Bool").nl
    w("from fan.sys.Num import Num").nl
    w("from fan.sys.Int import Int").nl
    w("from fan.sys.Float import Float").nl
    w("from fan.sys.Str import Str").nl
    w("from fan.sys.Range import Range").nl
    w("from fan.sys.Map import Map").nl
    w("from fan.sys.List import List").nl
    w("from fan.sys.Duration import Duration").nl
    w("from fan.sys.Locale import Locale").nl
    w("from fan.sys.StrBuf import StrBuf").nl
    // Reflection types
    w("from fan.sys.Type import Type").nl
    w("from fan.sys.Pod import Pod").nl
    w("from fan.sys.Slot import Slot").nl
    w("from fan.sys.Method import Method").nl
    w("from fan.sys.Field import Field").nl
    w("from fan.sys.Func import Func").nl
    w("from fan.sys.Env import Env").nl
    w("from fan.sys.Unsafe import Unsafe, make").nl
    w("from fan.sys.Err import Err, ParseErr, NullErr, CastErr, ArgErr, IndexErr, UnsupportedErr, UnknownTypeErr, UnknownPodErr, UnknownSlotErr, UnknownServiceErr, ReadonlyErr, IOErr, NotImmutableErr, CancelledErr, ConstErr, InterruptedErr, NameErr, TimeoutErr, TestErr, ReturnErr, NotFilterErr, UnknownNameErr, UnknownKeyErr").nl
    w("from fan.sys.Buf import Buf").nl
    w("from fan.sys.File import File").nl
    w("from fan.sys.Zip import Zip").nl
    w("from fan.sys.Process import Process").nl
    w("from fan.sys.Service import Service").nl
    // Additional runtime types
    w("from fan.sys.Regex import Regex, RegexMatcher").nl
    w("from fan.sys.Uri import Uri, UriScheme").nl
    w("from fan.sys.Unit import Unit").nl
    w("from fan.sys.MimeType import MimeType").nl
    w("from fan.sys.Charset import Charset").nl
    w("from fan.sys.Log import Log, LogLevel, LogRec").nl
    w("from fan.sys.Version import Version").nl
    w("from fan.sys.Weekday import Weekday").nl
    w("from fan.sys.TimeZone import TimeZone").nl
    w("from fan.sys.DateTime import DateTime, Month, Date, Time").nl
    w("from fan.sys.Uuid import Uuid").nl
    w("from fan.sys.Depend import Depend").nl
    w("from fan.sys.Decimal import Decimal").nl
    w("from fan.sys.Endian import Endian").nl
    w("from fan.sys.Enum import Enum").nl
    w("from fan.sys.Facet import Facet").nl
    w("from fan.sys.OutStream import OutStream").nl

    // Collect and import cross-pod types
    crossPodTypes := collectCrossPodTypes(t)
    crossPodTypes.each |types, podName|
    {
      if (podName == "sys") return  // Already imported above
      if (podName == t.pod.name) return  // Skip same-pod (handled at runtime)
      // Skip Java FFI pods - they can't be imported in Python
      if (PyUtil.isJavaFfi(podName)) return

      podPath := PyUtil.podImport(podName)
      types.each |typeName|
      {
        // Skip Java FFI types
        if (PyUtil.isJavaFfi(typeName)) return
        w("from ${podPath}.${typeName} import ${typeName}").nl
      }
    }

    // Import same-pod mixins that are used in class definition
    // These must be imported at module load time since Python needs base classes defined
    t.mixins.each |m|
    {
      if (m.qname == "sys::Obj") return  // Skip Obj
      if (m.pod.name == t.pod.name)
      {
        // Same-pod mixin - needs explicit import for class definition
        podPath := PyUtil.podImport(m.pod.name)
        w("from ${podPath}.${m.name} import ${m.name}").nl
      }
    }

    // NOTE: Other same-pod imports are handled at runtime via reflection or lazy imports
    // Automatic same-unit imports can cause circular import issues when helper classes
    // reference each other (e.g., FacetsA imports FacetsB imports FacetsA)

    // Exception: Same-pod exception types used in catch clauses need explicit imports
    // because they're used at statement level (except ErrType as e:) not via reflection
    samePodCatchTypes := collectSamePodCatchTypes(t)
    samePodCatchTypes.each |typeName|
    {
      // Skip self-import
      if (typeName == t.name) return
      podPath := PyUtil.podImport(t.pod.name)
      w("from ${podPath}.${typeName} import ${typeName}").nl
    }

    nl
  }

  ** Collect all cross-pod type references from a TypeDef
  ** Returns a map of podName -> Set of type names
  private Str:Str[] collectCrossPodTypes(TypeDef t)
  {
    result := Str:Str[][:]

    // Helper to add a type reference
    addType := |CType? ctype|
    {
      if (ctype == null) return
      // Unwrap nullable, list, map, func types
      ctype = unwrapType(ctype)
      if (ctype == null) return
      if (ctype.isSynthetic) return

      podName := ctype.pod.name
      typeName := ctype.name

      // Skip sys pod (already imported) and same pod (runtime handled)
      if (podName == "sys") return
      if (podName == t.pod.name) return

      // Add to result
      if (result[podName] == null) result[podName] = Str[,]
      if (!result[podName].contains(typeName))
        result[podName].add(typeName)
    }

    // Helper to add by pod/type name
    addByName := |Str podName, Str? typeName|
    {
      if (podName == "sys") return
      if (podName == t.pod.name) return
      if (typeName == null) return

      if (result[podName] == null) result[podName] = Str[,]
      if (!result[podName].contains(typeName))
        result[podName].add(typeName)
    }

    // Scan ALL pod dependencies for type references (like JS transpiler does)
    // This catches types from any dependent pod, not just those with explicit using statements
    t.pod.depends.each |depend|
    {
      podName := depend.name
      // Skip FFI imports (e.g., [java]java.io)
      if (podName.startsWith("[")) return
      // Skip sys pod (already imported) and same pod (runtime handled)
      if (podName == "sys") return
      if (podName == t.pod.name) return

      // Scan all method bodies for types from this dependent pod
      t.methodDefs.each |m|
      {
        // Scan method body
        if (m.code != null)
          scanBlockForTypes(m.code, podName, addByName)
        // Also scan constructor chaining (: super(...) or : this(...))
        // This catches types like Marker.val in: super("sys::Marker", type, Marker.val)
        if (m.ctorChain != null)
        {
          m.ctorChain.args.each |arg|
          {
            scanExprForTypes(arg, podName, addByName)
          }
        }
      }
    }

    // Also scan using statements for explicit type imports
    t.unit.usings.each |u|
    {
      // Skip FFI imports (e.g., [java]java.io::RandomAccessFile)
      if (u.podName.startsWith("[")) return

      if (u.typeName != null)
      {
        // Specific type import: using concurrent::Actor
        addByName(u.podName, u.typeName)
      }
    }

    // Base class and mixins
    if (t.base != null) addType(t.base)
    t.mixins.each |m| { addType(m) }

    // Field types
    t.fieldDefs.each |f|
    {
      addType(f.type)
    }

    // Method return types and parameter types
    t.methodDefs.each |m|
    {
      addType(m.returns)
      m.params.each |p|
      {
        addType(p.type)
      }
    }

    return result
  }

  ** Collect same-pod exception types used in catch clauses
  ** These need explicit imports because they're used at statement level
  private Str[] collectSamePodCatchTypes(TypeDef t)
  {
    result := Str[,]

    // Scan all methods for catch clauses
    t.methodDefs.each |m|
    {
      if (m.code != null)
        scanBlockForCatchTypes(m.code, t.pod.name, result)
    }

    return result
  }

  ** Scan a block for same-pod catch types
  private Void scanBlockForCatchTypes(Block block, Str podName, Str[] result)
  {
    block.stmts.each |stmt|
    {
      if (stmt.id == StmtId.tryStmt)
      {
        tryStmt := stmt as TryStmt
        tryStmt.catches.each |c|
        {
          if (c.errType != null && c.errType.pod.name == podName)
          {
            typeName := c.errType.name
            if (!result.contains(typeName))
              result.add(typeName)
          }
        }
        // Recurse into try block
        scanBlockForCatchTypes(tryStmt.block, podName, result)
        tryStmt.catches.each |c| { scanBlockForCatchTypes(c.block, podName, result) }
        if (tryStmt.finallyBlock != null)
          scanBlockForCatchTypes(tryStmt.finallyBlock, podName, result)
      }
      else if (stmt.id == StmtId.ifStmt)
      {
        ifStmt := stmt as IfStmt
        scanBlockForCatchTypes(ifStmt.trueBlock, podName, result)
        if (ifStmt.falseBlock != null) scanBlockForCatchTypes(ifStmt.falseBlock, podName, result)
      }
      else if (stmt.id == StmtId.forStmt)
      {
        forStmt := stmt as ForStmt
        if (forStmt.block != null) scanBlockForCatchTypes(forStmt.block, podName, result)
      }
      else if (stmt.id == StmtId.whileStmt)
      {
        whileStmt := stmt as WhileStmt
        scanBlockForCatchTypes(whileStmt.block, podName, result)
      }
      else if (stmt.id == StmtId.switchStmt)
      {
        switchStmt := stmt as SwitchStmt
        switchStmt.cases.each |c| { scanBlockForCatchTypes(c.block, podName, result) }
        if (switchStmt.defaultBlock != null) scanBlockForCatchTypes(switchStmt.defaultBlock, podName, result)
      }
    }
  }

  ** Unwrap nullable, list, map, func types to get the base type
  private CType? unwrapType(CType? t)
  {
    if (t == null) return null
    // Unwrap nullable
    if (t.isNullable) t = t.toNonNullable
    // For list/map/func, we'd need to recurse, but for imports we just need the outer type
    return t
  }

  ** Scan a block for type references from a specific pod
  ** This finds construction calls, static method calls, etc.
  private Void scanBlockForTypes(Block block, Str podName, |Str,Str?| addByName)
  {
    block.stmts.each |stmt|
    {
      scanStmtForTypes(stmt, podName, addByName)
    }
  }

  ** Scan a statement for type references
  private Void scanStmtForTypes(Stmt stmt, Str podName, |Str,Str?| addByName)
  {
    // Handle different statement types
    switch (stmt.id)
    {
      case StmtId.expr:
        scanExprForTypes((stmt as ExprStmt).expr, podName, addByName)
      case StmtId.localDef:
        localDef := stmt as LocalDefStmt
        if (localDef.init != null)
          scanExprForTypes(localDef.init, podName, addByName)
        // Check local variable type
        if (localDef.ctype != null && localDef.ctype.pod.name == podName)
          addByName(podName, localDef.ctype.name)
      case StmtId.ifStmt:
        ifStmt := stmt as IfStmt
        scanExprForTypes(ifStmt.condition, podName, addByName)
        scanBlockForTypes(ifStmt.trueBlock, podName, addByName)
        if (ifStmt.falseBlock != null)
          scanBlockForTypes(ifStmt.falseBlock, podName, addByName)
      case StmtId.returnStmt:
        ret := stmt as ReturnStmt
        if (ret.expr != null)
          scanExprForTypes(ret.expr, podName, addByName)
      case StmtId.forStmt:
        forStmt := stmt as ForStmt
        if (forStmt.init != null) scanStmtForTypes(forStmt.init, podName, addByName)
        if (forStmt.condition != null) scanExprForTypes(forStmt.condition, podName, addByName)
        if (forStmt.update != null) scanExprForTypes(forStmt.update, podName, addByName)
        scanBlockForTypes(forStmt.block, podName, addByName)
      case StmtId.whileStmt:
        whileStmt := stmt as WhileStmt
        scanExprForTypes(whileStmt.condition, podName, addByName)
        scanBlockForTypes(whileStmt.block, podName, addByName)
      case StmtId.tryStmt:
        tryStmt := stmt as TryStmt
        scanBlockForTypes(tryStmt.block, podName, addByName)
        tryStmt.catches.each |c|
        {
          if (c.errType != null && c.errType.pod.name == podName)
            addByName(podName, c.errType.name)
          scanBlockForTypes(c.block, podName, addByName)
        }
        if (tryStmt.finallyBlock != null)
          scanBlockForTypes(tryStmt.finallyBlock, podName, addByName)
      case StmtId.switchStmt:
        switchStmt := stmt as SwitchStmt
        scanExprForTypes(switchStmt.condition, podName, addByName)
        switchStmt.cases.each |c|
        {
          c.cases.each |caseExpr| { scanExprForTypes(caseExpr, podName, addByName) }
          scanBlockForTypes(c.block, podName, addByName)
        }
        if (switchStmt.defaultBlock != null)
          scanBlockForTypes(switchStmt.defaultBlock, podName, addByName)
      case StmtId.throwStmt:
        throwStmt := stmt as ThrowStmt
        scanExprForTypes(throwStmt.exception, podName, addByName)
    }
  }

  ** Scan an expression for type references
  private Void scanExprForTypes(Expr expr, Str podName, |Str,Str?| addByName)
  {
    // Handle construction calls: Coord(lat, lng)
    if (expr.id == ExprId.construction)
    {
      callExpr := expr as CallExpr
      if (callExpr.method.parent.pod.name == podName)
        addByName(podName, callExpr.method.parent.name)
      callExpr.args.each |arg| { scanExprForTypes(arg, podName, addByName) }
      return
    }

    // Handle call expressions
    if (expr.id == ExprId.call)
    {
      callExpr := expr as CallExpr

      // Special case: Type.find("pod::ClassName") - parse the string literal
      // This is used in verifyErr() and other reflection-based code
      if (callExpr.method.name == "find" && callExpr.method.parent.qname == "sys::Type")
      {
        if (!callExpr.args.isEmpty)
        {
          firstArg := callExpr.args.first
          if (firstArg.id == ExprId.strLiteral)
          {
            lit := firstArg as LiteralExpr
            qname := lit.val as Str
            if (qname != null && qname.contains("::"))
            {
              colonIdx := qname.index("::")
              typePod := qname[0..<colonIdx]
              typeName := qname[colonIdx+2..-1]
              if (typePod == podName)
                addByName(podName, typeName)
            }
          }
        }
      }

      // Static method calls: Coord.fromStr(...)
      if (callExpr.target != null)
        scanExprForTypes(callExpr.target, podName, addByName)
      // Check if method is from target pod
      if (callExpr.method.parent.pod.name == podName)
        addByName(podName, callExpr.method.parent.name)
      callExpr.args.each |arg| { scanExprForTypes(arg, podName, addByName) }
      return
    }

    // Handle static target: Coord.make
    if (expr.id == ExprId.staticTarget)
    {
      staticTarget := expr as StaticTargetExpr
      if (staticTarget.ctype.pod.name == podName)
        addByName(podName, staticTarget.ctype.name)
      return
    }

    // Handle field expressions: Marker.val (static field access)
    if (expr.id == ExprId.field)
    {
      fieldExpr := expr as FieldExpr
      // If field has a target (e.g., staticTarget), scan it for types
      if (fieldExpr.target != null)
        scanExprForTypes(fieldExpr.target, podName, addByName)
      // Also check if field's parent type is from target pod
      if (fieldExpr.field.parent.pod.name == podName)
        addByName(podName, fieldExpr.field.parent.name)
      return
    }

    // Handle type literal: Coord#
    if (expr.id == ExprId.typeLiteral)
    {
      typeLit := expr as LiteralExpr
      ctype := typeLit.val as CType
      if (ctype != null && ctype.pod.name == podName)
        addByName(podName, ctype.name)
      return
    }

    // Handle binary expressions (including assign, same, notSame, boolOr, boolAnd, elvis)
    if (expr is BinaryExpr)
    {
      binExpr := expr as BinaryExpr
      scanExprForTypes(binExpr.lhs, podName, addByName)
      scanExprForTypes(binExpr.rhs, podName, addByName)
      return
    }

    // Handle ternary
    if (expr is TernaryExpr)
    {
      ternary := expr as TernaryExpr
      scanExprForTypes(ternary.condition, podName, addByName)
      scanExprForTypes(ternary.trueExpr, podName, addByName)
      scanExprForTypes(ternary.falseExpr, podName, addByName)
      return
    }

    // Handle unary expressions (cmpNull, cmpNotNull, boolNot)
    if (expr is UnaryExpr)
    {
      unary := expr as UnaryExpr
      scanExprForTypes(unary.operand, podName, addByName)
      return
    }

    // Handle shortcut expressions (comparisons like <, >, ==, etc.)
    if (expr is ShortcutExpr)
    {
      shortcut := expr as ShortcutExpr
      scanExprForTypes(shortcut.target, podName, addByName)
      shortcut.args.each |arg| { scanExprForTypes(arg, podName, addByName) }
      return
    }

    // Handle closures
    if (expr.id == ExprId.closure)
    {
      closure := expr as ClosureExpr
      // Try closure.code first (original code block)
      if (closure.code != null)
        scanBlockForTypes(closure.code, podName, addByName)
      // Also check doCall method (synthetic method created for closure)
      // After compiler processing, code may have been moved to doCall
      if (closure.doCall != null && closure.doCall.code != null)
        scanBlockForTypes(closure.doCall.code, podName, addByName)
      return
    }

    // Handle list literals: [HisItem(ts, NA.val)]
    if (expr.id == ExprId.listLiteral)
    {
      listLit := expr as ListLiteralExpr
      listLit.vals.each |val| { scanExprForTypes(val, podName, addByName) }
      return
    }

    // Handle map literals: ["key": Marker.val]
    if (expr.id == ExprId.mapLiteral)
    {
      mapLit := expr as MapLiteralExpr
      mapLit.keys.each |key| { scanExprForTypes(key, podName, addByName) }
      mapLit.vals.each |val| { scanExprForTypes(val, podName, addByName) }
      return
    }

    // Handle coerce/cast
    if (expr.id == ExprId.coerce)
    {
      coerce := expr as TypeCheckExpr
      scanExprForTypes(coerce.target, podName, addByName)
      if (coerce.check.pod.name == podName)
        addByName(podName, coerce.check.name)
      return
    }

    // Handle is/as
    if (expr.id == ExprId.isExpr || expr.id == ExprId.asExpr)
    {
      typeCheck := expr as TypeCheckExpr
      scanExprForTypes(typeCheck.target, podName, addByName)
      if (typeCheck.check.pod.name == podName)
        addByName(podName, typeCheck.check.name)
      return
    }

    // Handle throw expressions
    if (expr.id == ExprId.throwExpr)
    {
      throwExpr := expr as ThrowExpr
      scanExprForTypes(throwExpr.exception, podName, addByName)
      return
    }
  }

//////////////////////////////////////////////////////////////////////////
// Class
//////////////////////////////////////////////////////////////////////////

  private Void classDef(TypeDef t)
  {
    // class ClassName(Mixin1, Mixin2, BaseClass):
    // Python supports multiple inheritance - include all mixins plus base class
    w("class ${t.name}")
    w("(")

    bases := Str[,]

    // Collect all mixins that aren't inherited by other mixins
    // This prevents Python MRO conflicts like class X(Dict, LibDepend)
    // where LibDepend already extends Dict
    mixinsToInclude := CType[,]
    t.mixins.each |m|
    {
      if (m.qname == "sys::Obj") return  // Skip Obj

      // Check if this mixin is inherited by another mixin in the list
      alreadyInherited := t.mixins.any |other|
      {
        if (other.qname == m.qname) return false  // Skip self
        // Check if 'other' mixin extends 'm'
        return other.mixins.any |mm| { mm.qname == m.qname }
      }

      if (!alreadyInherited)
        mixinsToInclude.add(m)
    }

    // Add filtered mixins
    mixinsToInclude.each |m|
    {
      bases.add(m.name)
    }

    // Add base class if it's not Obj and not already inherited via mixins
    baseAlreadyInherited := t.base != null && !t.base.isObj &&
      mixinsToInclude.any |m| {
        if (m.base?.qname == t.base.qname) return true
        return m.mixins.any |mm| { mm.qname == t.base.qname }
      }

    if (t.base != null && !t.base.isObj && !baseAlreadyInherited)
      bases.add(t.base.name)
    else if (bases.isEmpty)
      bases.add("Obj")

    // Write the bases
    w(bases.join(", "))
    w(")")
    colon

    indent

    // Check if this is an enum type
    if (t.isEnum)
    {
      enumClassDef(t)
    }
    else
    {
      // Static fields (class-level attributes) - must come first
      staticFields(t)

      // Constructor
      ctor(t)

      // Field getters/setters (instance fields only)
      t.fieldDefs.each |f|
      {
        if (f.isStatic) return
        fieldAccessors(f)
      }

      // Methods - track which field accessors we've already emitted
      emittedAccessors := Str:Bool[:]
      t.methodDefs.each |m|
      {
        if (m.isCtor) return
        if (m.isInstanceInit) return
        if (m.isStaticInit) return
        // Allow once helper methods (synthetic but needed) - they end with $Once
        if (m.isSynthetic && !m.name.endsWith("\$Once")) return
        // Skip abstract methods in mixins - they must be implemented by concrete class
        // Python MRO would find the mixin's pass-returning method before the base class implementation
        if (m.isAbstract && t.isMixin) return

        // For field accessors, emit combined getter/setter only once
        if (m.isFieldAccessor)
        {
          fieldName := m.accessorFor.name
          if (emittedAccessors[fieldName] == true) return  // Already emitted
          emittedAccessors[fieldName] = true
          combinedFieldAccessor(m.accessorFor)
          return
        }

        method(m)
      }

      // Generate Python operator methods for Fantom operator methods
      operatorMethods(t)

      // If no methods, add pass
      if (t.methodDefs.isEmpty)
        pass
    }

    unindent
    nl
  }

  ** Generate Python operator methods (__add__, __sub__, etc.)
  ** for Fantom methods with @Operator facet
  private Void operatorMethods(TypeDef t)
  {
    // Map Fantom operator methods to Python special methods
    operatorMap := Str:Str[
      "plus": "__add__",
      "minus": "__sub__",
      "mult": "__mul__",
      "div": "__truediv__",
      "mod": "__mod__",
      "negate": "__neg__",
      "get": "__getitem__",
      "set": "__setitem__"
    ]

    t.methodDefs.each |m|
    {
      // Skip methods without @Operator facet
      hasOperator := m.facets?.any |f| { f.type.qname == "sys::Operator" } ?: false
      if (!hasOperator) return

      pyMethod := operatorMap[m.name]
      if (pyMethod == null) return

      // Generate Python operator method
      nl
      w("def ${pyMethod}(self")
      if (m.params.size > 0)
      {
        w(", other")
      }
      w(")").colon
      indent
      if (m.params.size > 0)
      {
        w("return self.${escapeName(m.name)}(other)").eos
      }
      else
      {
        w("return self.${escapeName(m.name)}()").eos
      }
      unindent
    }
  }

//////////////////////////////////////////////////////////////////////////
// Enum
//////////////////////////////////////////////////////////////////////////

  ** Generate enum class definition
  private Void enumClassDef(TypeDef t)
  {
    enumFields := t.fieldDefs.findAll |f| { f.enumDef != null }
      .sort |a, b| { a.enumDef.ordinal <=> b.enumDef.ordinal }

    // Generate static fields (including once storage fields) for enum
    // This is needed for enums with once methods like UnitQuantity.unitToQuantity
    staticFields(t)

    // Private cache field for vals
    nl
    w("_vals = None").nl

    // Static accessor for each enum value: A(), B(), C()
    enumFields.each |f|
    {
      def := f.enumDef
      nl
      w("@staticmethod").nl
      w("def ${escapeName(def.name)}()").colon
      indent
      w("return ${t.name}.vals().get(${def.ordinal})").eos
      unindent
    }

    // vals() method - creates and caches enum instances
    nl
    w("@staticmethod").nl
    w("def vals()").colon
    indent
    w("if ${t.name}._vals is None").colon
    indent
    w("${t.name}._vals = List.to_immutable(List.from_list([").nl
    indent
    enumFields.each |f, i|
    {
      def := f.enumDef
      w("${t.name}._make_enum(${def.ordinal}, ${def.name.toCode}")
      if (!def.ctorArgs.isEmpty)
      {
        def.ctorArgs.each |arg|
        {
          w(", ")
          PyExprPrinter(this).expr(arg)
        }
      }
      w(")")
      if (i < enumFields.size - 1) w(",")
      nl
    }
    unindent
    w("]))").eos
    unindent
    w("return ${t.name}._vals").eos
    unindent

    // from_str() method
    nl
    w("@staticmethod").nl
    w("def from_str(name, checked=True)").colon
    indent
    w("for v in ${t.name}.vals()").colon
    indent
    w("if v.name() == name").colon
    indent
    w("return v").eos
    unindent
    unindent
    w("if checked").colon
    indent
    w("raise ParseErr.make(\"Unknown enum: \" + name)").eos
    unindent
    w("return None").eos
    unindent

    // _make_enum() internal factory
    nl
    w("@staticmethod").nl
    w("def _make_enum(_ordinal, _name")
    // Add ctor params if enum has custom constructor (skip first 2: ordinal, name)
    ctorMethod := t.methodDefs.find |m| { m.isCtor }
    if (ctorMethod != null && ctorMethod.params.size > 2)
    {
      ctorMethod.params[2..-1].each |p|
      {
        w(", ")
        w(escapeName(p.name))
        // Add default value if param has one
        if (p.hasDefault)
        {
          w("=")
          PyExprPrinter(this).expr(p->def)
        }
      }
    }
    w(")").colon
    indent
    w("inst = object.__new__(${t.name})").eos
    w("inst._ordinal = _ordinal").eos
    w("inst._name = _name").eos
    // Initialize custom fields from ctor params (skip first 2: ordinal, name)
    if (ctorMethod != null && ctorMethod.params.size > 2)
    {
      ctorMethod.params[2..-1].each |p|
      {
        w("inst._${escapeName(p.name)} = ${escapeName(p.name)}").eos
      }
    }
    // Run constructor body to compute derived fields
    if (ctorMethod != null && ctorMethod.code != null && !ctorMethod.code.stmts.isEmpty)
    {
      // Need to bind 'self' for the constructor body
      w("self = inst").eos
      stmtPrinter := PyStmtPrinter(this)
      stmtPrinter.scanMethodForClosures(ctorMethod.code)
      ctorMethod.code.stmts.each |s, idx|
      {
        this.m.stmtIndex = idx
        // Skip synthetic return statements
        if (s.id == StmtId.returnStmt)
        {
          ret := s as ReturnStmt
          if (ret.expr == null || ret.isSynthetic) return
        }
        stmtPrinter.stmt(s)
      }
      this.m.clearClosures()
    }
    w("return inst").eos
    unindent

    // ordinal() method
    nl
    w("def ordinal(self)").colon
    indent
    w("return self._ordinal").eos
    unindent

    // name() method
    nl
    w("def name(self)").colon
    indent
    w("return self._name").eos
    unindent

    // to_str() returns the name
    nl
    w("def to_str(self)").colon
    indent
    w("return self._name").eos
    unindent

    // __str__ for Python
    nl
    w("def __str__(self)").colon
    indent
    w("return self._name").eos
    unindent

    // equals - enums are singletons, use identity
    nl
    w("def equals(self, other)").colon
    indent
    w("return self is other").eos
    unindent

    // compare by ordinal
    nl
    w("def compare(self, other)").colon
    indent
    w("return self._ordinal - other._ordinal").eos
    unindent

    // Python comparison operators
    nl
    w("def __lt__(self, other)").colon
    indent
    w("return self._ordinal < other._ordinal").eos
    unindent

    nl
    w("def __le__(self, other)").colon
    indent
    w("return self._ordinal <= other._ordinal").eos
    unindent

    nl
    w("def __gt__(self, other)").colon
    indent
    w("return self._ordinal > other._ordinal").eos
    unindent

    nl
    w("def __ge__(self, other)").colon
    indent
    w("return self._ordinal >= other._ordinal").eos
    unindent

    nl
    w("def __eq__(self, other)").colon
    indent
    w("if not isinstance(other, ${t.name})").colon
    indent
    w("return False").eos
    unindent
    w("return self._ordinal == other._ordinal").eos
    unindent

    nl
    w("def __hash__(self)").colon
    indent
    w("return hash(self._ordinal)").eos
    unindent

    // Field getters for custom fields (skip enum values and vals field)
    t.fieldDefs.each |f|
    {
      if (f.enumDef != null) return  // Skip enum value fields (A, B, C)
      if (f.name == "vals") return   // Skip vals - we generate our own static vals()
      if (f.isStatic) return         // Skip other static fields
      fieldAccessors(f)
    }

    // Additional methods (like negOrdinal in EnumAbc)
    // Also allows $Once helper methods for once methods on enums
    t.methodDefs.each |m|
    {
      if (m.isCtor) return
      if (m.isInstanceInit) return
      if (m.isStaticInit) return
      // Allow once helper methods (synthetic but needed) - they end with $Once
      if (m.isSynthetic && !m.name.endsWith("\$Once")) return
      if (m.name == "fromStr") return  // Already generated

      method(m)
    }
  }

//////////////////////////////////////////////////////////////////////////
// Constructor
//////////////////////////////////////////////////////////////////////////

  private Void ctor(TypeDef t)
  {
    // Find ALL constructors
    ctorMethods := t.methodDefs.findAll |m| { m.isCtor }

    // Separate static ctors (factories) from instance ctors
    // Static ctor: `static new make(...)` - just a factory, body should NOT go in __init__
    // Instance ctor: `new make(...)` - body goes in __init__
    instanceCtors := ctorMethods.findAll |m| { !m.isStatic }
    staticCtors := ctorMethods.findAll |m| { m.isStatic }

    // If no constructors, use a simple default
    if (ctorMethods.isEmpty)
    {
      // Generate static make() factory method with no params
      nl
      w("@staticmethod").nl
      w("def make()").colon
      indent
      w("return ${t.name}()").eos
      unindent

      // Generate __init__ constructor
      // For mixins, use *args, **kwargs to support cooperative multiple inheritance
      nl
      if (t.isMixin)
      {
        w("def __init__(self, *args, **kwargs)").colon
        indent
        w("super().__init__(*args, **kwargs)").eos
      }
      else
      {
        w("def __init__(self)").colon
        indent
        w("super().__init__()").eos
      }
      // Instance field initialization
      t.fieldDefs.each |f|
      {
        if (f.isStatic) return
        fieldInit(f)
      }
      unindent
      nl
      return
    }

    // Find the primary constructor for __init__:
    // - Prefer instance ctor named "make", else first instance ctor
    // - If no instance ctors, use first static ctor but __init__ will have minimal body
    primaryCtor := instanceCtors.find |m| { m.name == "make" } ?: instanceCtors.first
    hasInstanceCtor := primaryCtor != null
    if (primaryCtor == null)
      primaryCtor = staticCtors.find |m| { m.name == "make" } ?: staticCtors.first

    // Generate static factory methods for ALL constructors
    ctorMethods.each |ctorMethod|
    {
      ctorName := escapeName(ctorMethod.name)  // "make", "make_def", etc. (snake_case)
      isStaticFactory := ctorMethod.isStatic  // static new make(...) vs new make(...)

      nl
      w("@staticmethod").nl
      w("def ${ctorName}(")
      ctorMethod.params.each |p, i|
      {
        if (i > 0) w(", ")
        w(escapeName(p.name))
        if (p.hasDefault)
        {
          w("=None")
        }
      }
      w(")")
      colon
      indent

      // For static factories: run the factory body code (they call other ctors internally)
      // For instance ctors: create instance and run body
      if (isStaticFactory)
      {
        // Static factory - run the body code which creates/returns instance
        // The body will call other ctors like makeImpl or makeSegs
        emitDefaultParamChecks(ctorMethod)
        if (ctorMethod.code != null && !ctorMethod.code.stmts.isEmpty)
        {
          // Mark static context
          this.m.inStaticContext = true
          stmtPrinter := PyStmtPrinter(this)
          stmtPrinter.scanMethodForClosures(ctorMethod.code)
          ctorMethod.code.stmts.each |s, idx|
          {
            this.m.stmtIndex = idx
            stmtPrinter.stmt(s)
          }
          this.m.clearClosures()
          this.m.inStaticContext = false
        }
        else
        {
          pass
        }
      }
      else if (ctorName != "make")
      {
        // Named instance constructor (not "make") - create instance and run ctor body
        w("inst = object.__new__(${t.name})").eos

        // Check if this ctor chains to this.make() - if so, skip _ctor_init
        // because __init__() will handle field initialization
        chainsToThisMake := ctorMethod.ctorChain != null &&
          (ctorMethod.ctorChain.target == null || ctorMethod.ctorChain.target.id == ExprId.thisExpr) &&
          ctorMethod.ctorChain.method.name == "make"

        if (!chainsToThisMake)
        {
          w("inst._ctor_init()").eos  // Initialize fields only if not chaining to make()
        }

        // Call the instance body method with params
        w("inst._${ctorName}_body(")
        ctorMethod.params.each |p, i|
        {
          if (i > 0) w(", ")
          w(escapeName(p.name))
        }
        w(")").eos
        w("return inst").eos
      }
      else
      {
        // Primary instance make() just delegates to __init__
        w("return ${t.name}(")
        ctorMethod.params.each |p, i|
        {
          if (i > 0) w(", ")
          w(escapeName(p.name))
        }
        w(")").eos
      }
      unindent
    }

    // Generate instance body methods for named constructors
    ctorMethods.each |ctorMethod|
    {
      if (ctorMethod.name == "make") return  // Primary ctor uses __init__

      nl
      w("def _${escapeName(ctorMethod.name)}_body(self")
      ctorMethod.params.each |p|
      {
        w(", ")
        w(escapeName(p.name))
        if (p.hasDefault)
        {
          w("=None")
        }
      }
      w(")").colon
      indent

      emittedStmts := false

      // Handle constructor chaining (: this.make(...) or : super(...))
      if (ctorMethod.ctorChain != null)
      {
        chain := ctorMethod.ctorChain
        // Check if chaining to this or super
        isThisChain := chain.target == null || chain.target.id == ExprId.thisExpr
        isSuperChain := chain.target != null && chain.target.id == ExprId.superExpr

        if (isThisChain)
        {
          // this.make(...) - call another constructor on this type
          chainCtorName := chain.method.name
          if (chainCtorName == "make")
          {
            // Call __init__ directly to chain to primary constructor
            w("self.__init__(")
            chain.args.each |arg, i|
            {
              if (i > 0) w(", ")
              PyExprPrinter(this).expr(arg)
            }
            w(")").eos
          }
          else
          {
            // Chain to another named constructor's body
            w("self._${escapeName(chainCtorName)}_body(")
            chain.args.each |arg, i|
            {
              if (i > 0) w(", ")
              PyExprPrinter(this).expr(arg)
            }
            w(")").eos
          }
        }
        else if (isSuperChain)
        {
          // super(...) - call parent constructor with chain arguments
          // This re-calls parent's __init__ with actual arguments to set up parent fields
          chainCtorName := chain.method.name
          if (chainCtorName == "make")
          {
            // Call parent's __init__ with arguments
            w("super().__init__(")
            chain.args.each |arg, i|
            {
              if (i > 0) w(", ")
              PyExprPrinter(this).expr(arg)
            }
            w(")").eos
          }
          else
          {
            // Call parent's named constructor body
            w("super()._${escapeName(chainCtorName)}_body(")
            chain.args.each |arg, i|
            {
              if (i > 0) w(", ")
              PyExprPrinter(this).expr(arg)
            }
            w(")").eos
          }
        }
        emittedStmts = true
      }

      if (ctorMethod.code != null && !ctorMethod.code.stmts.isEmpty)
      {
        stmtPrinter := PyStmtPrinter(this)
        stmtPrinter.scanMethodForClosures(ctorMethod.code)
        ctorMethod.code.stmts.each |s, idx|
        {
          this.m.stmtIndex = idx
          // Skip synthetic return statements
          if (s.id == StmtId.returnStmt)
          {
            ret := s as ReturnStmt
            if (ret.expr == null || ret.isSynthetic) return
          }
          // Skip synthetic instance init calls and enterCtor/exitCtor (field-not-set checks)
          if (s.id == StmtId.expr)
          {
            exprStmt := s as ExprStmt
            if (exprStmt.expr.id == ExprId.call)
            {
              call := exprStmt.expr as CallExpr
              if (call.method.name.contains("\$init\$")) return
              // Skip Fantom's enterCtor/exitCtor field-not-set checking (not needed in Python)
              if (call.method.name == "enterCtor" || call.method.name == "exitCtor") return
            }
          }
          stmtPrinter.stmt(s)
          emittedStmts = true
        }
        this.m.clearClosures()
      }
      if (!emittedStmts)
      {
        pass
      }
      unindent
    }

    // Generate _ctor_init helper for field initialization (used by named ctors)
    // This method ONLY initializes THIS class's fields - it does NOT call parent.
    // Named constructor body methods (like _makeResolved_body) are responsible
    // for calling the appropriate parent constructor with proper arguments.
    if (ctorMethods.size > 1 || (ctorMethods.size == 1 && ctorMethods.first.name != "make"))
    {
      nl
      w("def _ctor_init(self)").colon
      indent

      // Check if parent will have _ctor_init (multiple ctors or named ctors)
      parentHasMultipleCtors := t.base != null && !t.base.isObj && t.base.ctors.size > 1
      parentHasNamedCtors := t.base != null && !t.base.isObj &&
        t.base.ctors.any |ctor| { ctor.name != "make" }
      parentWillHaveCtorInit := parentHasMultipleCtors || parentHasNamedCtors

      hasFieldsToInit := t.fieldDefs.any |f| { !f.isStatic }
      hasInstanceInit := t.methodDefs.any |m| { m.isInstanceInit && m.code != null }

      if (parentWillHaveCtorInit)
      {
        // Parent has _ctor_init, so we can call it to initialize parent fields
        w("super()._ctor_init()").eos
      }
      else if (!hasFieldsToInit && !hasInstanceInit)
      {
        // No parent call, no fields, no instance init - need pass
        pass
      }
      // Otherwise, DO NOT call parent - the named constructor body will handle
      // the parent chain with proper arguments

      // Instance field initialization (THIS class's fields only)
      t.fieldDefs.each |f|
      {
        if (f.isStatic) return
        fieldInit(f)
      }
      // Instance init block
      instanceInitMethod := t.methodDefs.find |m| { m.isInstanceInit }
      if (instanceInitMethod != null && instanceInitMethod.code != null)
      {
        stmtPrinter := PyStmtPrinter(this)
        stmtPrinter.scanMethodForClosures(instanceInitMethod.code)
        instanceInitMethod.code.stmts.each |s, idx|
        {
          this.m.stmtIndex = idx
          stmtPrinter.stmt(s)
        }
        this.m.clearClosures()
      }
      unindent
    }

    // Generate __init__ constructor (uses primary ctor's signature)
    // For mixins, use *args, **kwargs to support cooperative multiple inheritance
    nl
    if (t.isMixin)
    {
      w("def __init__(self, *args, **kwargs)")
    }
    else
    {
      w("def __init__(self")

      // Only emit params if we have an actual instance constructor
      // Static factories (static new) don't define instance constructor params
      if (hasInstanceCtor)
      {
        // In Python, once we emit a default parameter, ALL following params must have defaults
        // Find the first index where we should start emitting defaults:
        // - explicit hasDefault, OR
        // - nullable type AND all following params also have defaults or are nullable
        firstDefaultIdx := primaryCtor.params.size
        for (i := primaryCtor.params.size - 1; i >= 0; i--)
        {
          p := primaryCtor.params[i]
          if (p.hasDefault || p.type.isNullable)
            firstDefaultIdx = i
          else
            break  // Found a required param, stop
        }

        primaryCtor.params.each |p, i|
        {
          w(", ")
          w(escapeName(p.name))
          // Only add =None if at or after firstDefaultIdx
          if (i >= firstDefaultIdx)
          {
            w("=None")
          }
        }
      }
      w(")")
    }
    colon

    indent

    // Emit default parameter value checks at start of constructor body
    // Only do this if we have an actual instance constructor with params
    if (hasInstanceCtor)
      emitDefaultParamChecks(primaryCtor)

    // Call super().__init__() with constructor chain arguments
    // For mixins, pass through *args, **kwargs to support cooperative multiple inheritance
    if (t.isMixin)
    {
      w("super().__init__(*args, **kwargs)").eos
    }
    else
    {
      w("super().__init__(")
      if (hasInstanceCtor && primaryCtor.ctorChain != null)
      {
        chain := primaryCtor.ctorChain
        chain.args.each |arg, i|
        {
          if (i > 0) w(", ")
          PyExprPrinter(this).expr(arg)
        }
      }
      w(")").eos
    }

    // Instance field initialization
    t.fieldDefs.each |f|
    {
      if (f.isStatic) return
      fieldInit(f)
    }

    // Instance init block
    instanceInitMethod := t.methodDefs.find |m| { m.isInstanceInit }
    if (instanceInitMethod != null && instanceInitMethod.code != null)
    {
      stmtPrinter := PyStmtPrinter(this)
      stmtPrinter.scanMethodForClosures(instanceInitMethod.code)
      instanceInitMethod.code.stmts.each |s, idx|
      {
        this.m.stmtIndex = idx
        // Skip synthetic return statements (same filtering as primary ctor body)
        if (s.id == StmtId.returnStmt)
        {
          ret := s as ReturnStmt
          if (ret.expr == null || ret.isSynthetic) return
        }
        stmtPrinter.stmt(s)
      }
      this.m.clearClosures()
    }

    // Primary constructor body
    // ONLY emit body if primaryCtor is an instance ctor (not a static factory)
    // Static factories (static new make(...)) should NOT have their body in __init__
    // because they return newly constructed instances, not modify `self`
    if (hasInstanceCtor && primaryCtor.code != null)
    {
      stmtPrinter := PyStmtPrinter(this)
      stmtPrinter.scanMethodForClosures(primaryCtor.code)

      primaryCtor.code.stmts.each |s, idx|
      {
        this.m.stmtIndex = idx
        // Skip synthetic return statements
        if (s.id == StmtId.returnStmt)
        {
          ret := s as ReturnStmt
          if (ret.expr == null || ret.isSynthetic) return
          // Skip return statements that return construction calls (factory pattern)
          // These are static factory returns, not instance initialization
          if (ret.expr.id == ExprId.call || ret.expr.id == ExprId.construction) return
        }
        // Skip synthetic instance init calls and enterCtor/exitCtor (field-not-set checks)
        if (s.id == StmtId.expr)
        {
          exprStmt := s as ExprStmt
          if (exprStmt.expr.id == ExprId.call)
          {
            call := exprStmt.expr as CallExpr
            if (call.method.name.contains("\$init\$")) return
            // Skip Fantom's enterCtor/exitCtor field-not-set checking (not needed in Python)
            if (call.method.name == "enterCtor" || call.method.name == "exitCtor") return
          }
        }
        stmtPrinter.stmt(s)
      }
    }

    // Clear closure state
    this.m.clearClosures()

    unindent
    nl
  }

  private Void fieldInit(FieldDef f)
  {
    w("self._${escapeName(f.name)} = ")
    if (f.init != null)
      PyExprPrinter(this).expr(f.init)
    else
      w(defaultVal(f.type))
    eos
  }

  private Void fieldAccessors(FieldDef f)
  {
    // Skip if field has custom get/set accessors
    // Custom accessors are generated via combinedFieldAccessor() call below
    if (f.hasGet || f.hasSet) return

    name := escapeName(f.name)

    // Generate combined getter/setter: def fieldName(self, _val_=None):
    // This is required because PyExprPrinter.assign() uses method call syntax
    // for field assignments on transpiled types: target.fieldName(value)
    nl
    w("def ${name}(self, _val_=None)").colon
    indent
    w("if _val_ is None").colon
    indent
    w("return self._${name}").eos
    unindent
    w("else").colon
    indent
    w("self._${name} = _val_").eos
    unindent
    unindent
  }

  ** Default value for uninitialized fields.
  ** In Fantom:
  ** - Nullable types (?) always default to null
  ** - Non-nullable primitives (Int, Float, Bool) have type defaults (0, 0.0, false)
  ** - Non-nullable reference types (Str, List, etc.) start as null, must be initialized
  private Str defaultVal(CType t)
  {
    // Nullable types always default to None
    if (t.isNullable) return "None"

    sig := t.signature
    // Non-nullable primitives have type-specific defaults
    if (sig == "sys::Bool") return "False"
    if (sig == "sys::Int") return "0"
    if (sig == "sys::Float") return "0.0"

    // Non-nullable reference types (Str, List, etc.) start as None
    // They must be initialized by constructor - Fantom's type system enforces this
    return "None"
  }

  ** Type-specific default for static field getter fallback
  ** Used only when static field getter finds None after _static_init()
  private Str typeDefaultVal(CType t)
  {
    if (t.isNullable) return "None"
    sig := t.signature
    if (sig == "sys::Bool") return "False"
    if (sig == "sys::Int") return "0"
    if (sig == "sys::Float") return "0.0"
    if (sig == "sys::Str") return "\"\""
    return "None"
  }

//////////////////////////////////////////////////////////////////////////
// Static Fields
//////////////////////////////////////////////////////////////////////////

  ** Generate static fields with class-level storage and lazy-init getters
  ** Follows the JavaScript transpiler pattern from JsType.writeStaticField()
  private Void staticFields(TypeDef t)
  {
    // Collect names of once storage fields from once methods
    // When Fantom compiles a `once` method, it creates:
    //   1. A storage field: methodName$Store (synthetic)
    //   2. A helper method: methodName$Once (synthetic, contains original body)
    //   3. The original method modified to check storage and call helper
    // We identify once storage fields by finding methods with isOnce=true
    onceStorageFieldNames := Str:Bool[:]
    t.methodDefs.each |m|
    {
      if (m.isOnce)
        onceStorageFieldNames["${m.name}\$Store"] = true
    }

    // Find all static fields:
    // - Non-synthetic fields (normal static fields)
    // - Synthetic fields that are once storage (identified by method analysis above)
    // - Fields with isOnce flag set (compiler may also set this)
    staticFieldDefs := t.fieldDefs.findAll |f|
    {
      if (!f.isStatic) return false
      if (f.enumDef != null) return false  // Skip enum value fields - handled by vals()/_make_enum()
      if (!f.isSynthetic) return true  // Normal static field
      if (f.isOnce) return true         // Compiler marked as once
      if (onceStorageFieldNames.containsKey(f.name)) return true  // Backing storage for once method
      return false
    }
    if (staticFieldDefs.isEmpty) return

    // Check if there's a staticInit method
    staticInitMethod := t.methodDefs.find |m| { m.isStaticInit }

    // Generate class-level storage for each static field
    nl
    staticFieldDefs.each |f|
    {
      // Once fields use "_once_" as sentinel value, regular fields use None
      isOnceStorage := f.isOnce || onceStorageFieldNames.containsKey(f.name)
      if (isOnceStorage)
        w("_${escapeName(f.name)} = \"_once_\"").nl
      else
        w("_${escapeName(f.name)} = None").nl
    }

    // Generate static getter for each static field
    staticFieldDefs.each |f|
    {
      // Determine if this is a once storage field (synthetic backing for once method)
      isOnceStorage := f.isOnce || onceStorageFieldNames.containsKey(f.name)
      staticFieldGetter(t, f, staticInitMethod != null, isOnceStorage)
    }

    // Generate _static_init() method if there's a staticInit block or fields need init
    if (staticInitMethod != null || staticFieldDefs.any |f| { f.init != null })
    {
      staticInit(t, staticInitMethod, staticFieldDefs)
    }
  }

  ** Generate static getter method for a static field
  ** isOnceStorage: true if this field is backing storage for a once method
  private Void staticFieldGetter(TypeDef t, FieldDef f, Bool hasStaticInit, Bool isOnceStorage)
  {
    name := escapeName(f.name)
    typeName := t.name

    nl
    w("@staticmethod").nl
    w("def ${name}()").colon
    indent

    // Special handling for 'once' fields (either compiler-marked or identified as once storage)
    // Once fields use "_once_" as sentinel and call the $Once helper method
    if (isOnceStorage)
    {
      // The field name is like "specRef$Store", helper method is "specRef$Once"
      // We need to extract the base name and generate the helper call
      // Field name: specRef_Store (escaped from specRef$Store)
      // Helper method: specRef_Once (escaped from specRef$Once)
      baseName := f.name
      if (baseName.endsWith("\$Store"))
        baseName = baseName[0..<-6]  // Remove "$Store" suffix
      helperName := escapeName(baseName + "\$Once")

      w("if ${typeName}._${name} == \"_once_\"").colon
      indent
      w("${typeName}._${name} = ${typeName}.${helperName}()").eos
      unindent
      w("return ${typeName}._${name}").eos
    }
    else
    {
      // Regular static field - check if uninitialized, then initialize
      w("if ${typeName}._${name} is None").colon
      indent
      if (hasStaticInit || f.init != null)
      {
        w("${typeName}._static_init()").eos
      }
      // If still None after static init, use type-specific default value
      w("if ${typeName}._${name} is None").colon
      indent
      w("${typeName}._${name} = ${typeDefaultVal(f.type)}").eos
      unindent
      unindent

      w("return ${typeName}._${name}").eos
    }
    unindent
  }

  ** Generate _static_init() method that initializes all static fields
  ** Follows Fantom's source order: static blocks run before fields declared after them
  private Void staticInit(TypeDef t, MethodDef? staticInitMethod, FieldDef[] staticFieldDefs)
  {
    typeName := t.name

    nl
    w("@staticmethod").nl
    w("def _static_init()").colon
    indent

    // Add re-entry guard to prevent infinite recursion
    // This handles circular dependencies between static fields
    w("if hasattr(${typeName}, '_static_init_in_progress') and ${typeName}._static_init_in_progress").colon
    indent
    w("return").eos
    unindent
    w("${typeName}._static_init_in_progress = True").eos

    // Mark that we're in a static context (no 'self' available)
    m.inStaticContext = true

    // Collect enum field names for filtering (only for enum types)
    enumFieldNames := Str:Bool[:]
    if (t.isEnum)
    {
      t.fieldDefs.each |f|
      {
        if (f.enumDef != null)
          enumFieldNames[f.name] = true
      }
    }

    // If there's a static init method, it contains EVERYTHING (Fantom compiler combines
    // all static initialization into one method). Just emit it, skipping the final return
    // and enum value assignments (which are handled by vals()/_make_enum()).
    if (staticInitMethod != null && staticInitMethod.code != null)
    {
      stmtPrinter := PyStmtPrinter(this)
      stmtPrinter.scanMethodForClosures(staticInitMethod.code)
      staticInitMethod.code.stmts.each |s, idx|
      {
        this.m.stmtIndex = idx
        // Skip synthetic return at end - we'll handle cleanup after
        if (s.id == StmtId.returnStmt)
        {
          ret := s as ReturnStmt
          if (ret.expr == null) return  // Skip void return
        }
        // Skip enum value field assignments - they're handled by vals()/_make_enum()
        if (t.isEnum && isEnumFieldAssignment(s, enumFieldNames))
          return
        stmtPrinter.stmt(s)
      }
      this.m.clearClosures()
    }
    else
    {
      // No static block - just initialize fields with inline initializers
      staticFieldDefs.each |f|
      {
        if (f.init == null) return
        name := escapeName(f.name)
        w("if ${typeName}._${name} is None").colon
        indent
        w("${typeName}._${name} = ")
        PyExprPrinter(this).expr(f.init)
        eos
        unindent
      }
    }

    // Clear the re-entry guard
    w("${typeName}._static_init_in_progress = False").eos

    // Reset static context flag
    m.inStaticContext = false

    unindent
  }

  ** Generate combined getter/setter method for fields with custom accessors
  ** In Python, we combine them into one method with optional parameter
  private Void combinedFieldAccessor(FieldDef f)
  {
    name := escapeName(f.name)

    // Generate: def fieldName(self, _val_=None):
    //   if _val_ is None:
    //     # getter body
    //   else:
    //     # setter body
    nl
    w("def ${name}(self, _val_=None)").colon
    indent
    nl

    w("if _val_ is None").colon
    indent
    // Getter body
    if (f.get != null && f.get.code != null)
    {
      stmtPrinter := PyStmtPrinter(this)
      stmtPrinter.scanMethodForClosures(f.get.code)
      f.get.code.stmts.each |s, idx|
      {
        this.m.stmtIndex = idx
        stmtPrinter.stmt(s)
      }
      this.m.clearClosures()
    }
    else
    {
      w("return self._${name}").eos
    }
    unindent

    w("else").colon
    indent
    // Setter body - need to replace 'it' param with '_val_'
    if (f.set != null && f.set.code != null)
    {
      // Map 'it' to '_val_' for the setter body
      w("it = _val_").eos
      stmtPrinter := PyStmtPrinter(this)
      stmtPrinter.scanMethodForClosures(f.set.code)
      f.set.code.stmts.each |s, idx|
      {
        this.m.stmtIndex = idx
        stmtPrinter.stmt(s)
      }
      this.m.clearClosures()
    }
    else
    {
      w("self._${name} = _val_").eos
    }
    unindent

    unindent
  }

//////////////////////////////////////////////////////////////////////////
// Methods
//////////////////////////////////////////////////////////////////////////

  private Void method(MethodDef m)
  {
    this.m.curMethod = m

    // Set static context flag for static methods
    // This ensures calls like self.make() become ClassName.make()
    if (m.isStatic)
      this.m.inStaticContext = true

    nl

    // Static decorator
    if (m.isStatic)
      w("@staticmethod").nl

    // def method_name(self, params...):
    w("def ${escapeName(m.name)}(")
    if (!m.isStatic) w("self")

    m.params.each |p, i|
    {
      if (i > 0 || !m.isStatic) w(", ")
      w(escapeName(p.name))
      if (p.hasDefault)
      {
        w("=None")  // Default params simplified for bootstrap
      }
    }
    w(")")
    colon

    // Method body
    if (m.code == null || m.code.stmts.isEmpty)
    {
      indent
      // Even empty methods need default parameter handling
      emitDefaultParamChecks(m)
      if (!m.params.any |p| { p.hasDefault })
        pass
      unindent
    }
    else
    {
      indent

      // Emit default parameter value checks at start of method body
      // This follows the JavaScript transpiler pattern from JsType.doWriteMethod()
      emitDefaultParamChecks(m)

      // Scan method for closures to track usage
      stmtPrinter := PyStmtPrinter(this)
      stmtPrinter.scanMethodForClosures(m.code)

      // Emit statements (closures emitted lazily)
      m.code.stmts.each |s, idx|
      {
        this.m.stmtIndex = idx
        stmtPrinter.stmt(s)
      }

      unindent
    }

    // Clear closure state for next method
    this.m.clearClosures()

    // Generate Python main block for main() methods
    if (isMain(m))
      pyMain(m)

    // Reset static context flag
    if (m.isStatic)
      this.m.inStaticContext = false

    this.m.curMethod = null
  }

  ** Emit default parameter value checks at start of method body
  ** Follows JS transpiler pattern: if (param === undefined) param = defaultExpr;
  ** For Python: if param is None: param = defaultExpr
  private Void emitDefaultParamChecks(MethodDef m)
  {
    m.params.each |p|
    {
      if (!p.hasDefault) return
      name := escapeName(p.name)

      // Generate: if param is None: param = defaultValue
      w("if ${name} is None").colon
      indent
      w("${name} = ")
      // p.def_ is the default value expression - transpile it
      PyExprPrinter(this).expr(p->def)
      eos
      unindent
    }
  }

  ** Check if this is a main(Str[] args) method
  private Bool isMain(MethodDef m)
  {
    m.name == "main" && m.params.size == 1 && m.params[0].type.isList
  }

  ** Generate Python main block
  private Void pyMain(MethodDef m)
  {
    nl
    nl
    w("if __name__ == \"__main__\":").nl
    indent
    typeName := m.parent.name
    w("import sys as sys_mod").nl
    w("main_instance = ${typeName}()").nl
    w("main_instance.main(sys_mod.argv[1:])").nl
    unindent
  }

//////////////////////////////////////////////////////////////////////////
// Type Metadata (Reflection)
//////////////////////////////////////////////////////////////////////////

  ** Generate type metadata registration for reflection
  ** This is similar to how JsPod.writeTypeInfo() works for JavaScript
  private Void typeMetadata(TypeDef t)
  {
    // Skip synthetic types
    if (t.isSynthetic) return

    // Check if we have any slots to register
    hasSlots := t.fieldDefs.any |f| { !f.isSynthetic } ||
                t.methodDefs.any |m| { !m.isSynthetic && !m.isInstanceInit && !m.isStaticInit }

    // Always need to emit tf_() for type-level metadata (facets, mixins, base type)
    // even if there are no slots (e.g., mixins with only inherited members)
    hasFacets := t.facets != null && !t.facets.isEmpty
    hasMixins := !t.mixins.isEmpty && t.mixins.any |m| { m.qname != "sys::Obj" }
    hasBase := t.base != null && !t.base.isObj

    // Skip only if there's nothing to register
    if (!hasSlots && !hasFacets && !hasMixins && !hasBase) return

    nl
    w("# Type metadata registration for reflection").nl
    w("from fan.sys.Param import Param").nl
    w("from fan.sys.Slot import FConst").nl
    w("_t = Type.find('${t.qname}')").nl

    // Calculate type flags
    typeFlags := typeFlags(t)

    // Build mixin list
    mixinList := Str[,]
    t.mixins.each |m|
    {
      if (m.qname != "sys::Obj")
        mixinList.add("'${m.qname}'")
    }
    mixinsStr := "[" + mixinList.join(", ") + "]"

    // Register type-level facets with flags, mixins, and base type
    typeFacets := facetDict(t.facets)
    // Enums implicitly have @Serializable{simple=true}
    if (t.isEnum)
    {
      if (typeFacets == "{}")
        typeFacets = "{'sys::Serializable': {'simple': True}}"
      else if (!typeFacets.contains("sys::Serializable"))
        typeFacets = typeFacets[0..-2] + ", 'sys::Serializable': {'simple': True}}"
    }
    // Determine base type (non-Obj)
    baseStr := "None"
    if (t.base != null && !t.base.isObj)
      baseStr = "'${t.base.qname}'"
    // Always emit tf_() with flags, mixins, and base
    w("_t.tf_(${typeFacets}, ${typeFlags}, ${mixinsStr}, ${baseStr})").nl

    // Register fields (including enum value fields)
    t.fieldDefs.each |f|
    {
      if (f.isSynthetic) return

      flags := fieldFlags(f)
      typeSig := PyUtil.sanitizeJavaFfi(f.type.signature)
      fieldFacets := "{}"

      // Enum value fields get special flag handling and may have facets
      if (f.enumDef != null)
      {
        // Enum values are public static const
        enumFlags := 0x00000001.or(0x00000800).or(0x00002000).or(0x00000020)  // Public | Static | Const | Enum
        fieldFacets = facetDict(f.enumDef.facets)
        w("_t.af_('${escapeName(f.name)}', ${enumFlags}, '${typeSig}', ${fieldFacets})").nl
      }
      else
      {
        fieldFacets = facetDict(f.facets)
        setterFlags := setterFlags(f)
        // Only emit setter flags if they differ from field flags
        if (setterFlags != flags)
          w("_t.af_('${escapeName(f.name)}', ${flags}, '${typeSig}', ${fieldFacets}, ${setterFlags})").nl
        else
          w("_t.af_('${escapeName(f.name)}', ${flags}, '${typeSig}', ${fieldFacets})").nl
      }
    }

    // Register methods
    t.methodDefs.each |m|
    {
      if (m.isSynthetic) return
      if (m.isInstanceInit) return
      if (m.isStaticInit) return
      if (m.isFieldAccessor) return

      flags := methodFlags(m)
      retSig := PyUtil.sanitizeJavaFfi(m.returns.signature)
      methodFacets := facetDict(m.facets)

      // Build params list
      if (m.params.isEmpty)
      {
        w("_t.am_('${escapeName(m.name)}', ${flags}, '${retSig}', [], ${methodFacets})").nl
      }
      else
      {
        w("_t.am_('${escapeName(m.name)}', ${flags}, '${retSig}', [")
        m.params.each |p, i|
        {
          if (i > 0) w(", ")
          pType := PyUtil.sanitizeJavaFfi(p.type.signature)
          hasDefault := p.hasDefault ? "True" : "False"
          w("Param('${escapeName(p.name)}', Type.find('${pType}'), ${hasDefault})")
        }
        w("], ${methodFacets})").nl
      }
    }

    // Register implicit default constructor if no explicit (non-synthetic) ctors defined
    // The Fantom compiler adds a synthetic default ctor to methodDefs, so we check for non-synthetic
    // Types without explicit constructors get an implicit make() that needs reflection registration
    explicitCtors := t.methodDefs.findAll |m| { m.isCtor && !m.isSynthetic }
    if (explicitCtors.isEmpty && !t.isEnum && !t.isMixin)
    {
      // Implicit make() is public static constructor returning This
      // Flags: Public (0x1) | Ctor (0x100) | Static (0x800) = 0x901
      w("_t.am_('make', 2305, '${t.qname}', [], {})").nl
    }
  }

  ** Serialize facets to Python dict format: {'sys::Serializable': {'simple': True}}
  private Str facetDict(FacetDef[]? facets)
  {
    if (facets == null || facets.isEmpty) return "{}"

    s := StrBuf()
    s.addChar('{')
    facets.each |f, i|
    {
      if (i > 0) s.add(", ")
      s.addChar('\'').add(f.type.qname).add("': ")

      // Build the facet value dict
      if (f.names.isEmpty)
      {
        s.add("{}")
      }
      else
      {
        s.addChar('{')
        f.names.each |name, j|
        {
          if (j > 0) s.add(", ")
          s.addChar('\'').add(name).add("': ")
          // Serialize the value - convert to Python literal
          val := f.vals[j]
          s.add(exprToPython(val))
        }
        s.addChar('}')
      }
    }
    s.addChar('}')
    return s.toStr
  }

  ** Convert a Fantom expression to a Python literal string
  private Str exprToPython(Expr e)
  {
    if (e is LiteralExpr)
    {
      lit := e as LiteralExpr
      val := lit.val
      if (val == null) return "None"
      if (val is Bool) return val == true ? "True" : "False"
      if (val is Int) return val.toStr
      if (val is Float) return val.toStr
      if (val is Str) return val.toStr.toCode
      return val.toStr.toCode
    }
    // Fallback - use Fantom's serialization
    return e.serialize.toCode
  }

  ** Calculate field flags
  private Int fieldFlags(FieldDef f)
  {
    flags := 0
    if (f.isPublic) flags = flags.or(0x00000001)       // FConst.Public
    if (f.isPrivate) flags = flags.or(0x00000002)      // FConst.Private
    if (f.isProtected) flags = flags.or(0x00000004)    // FConst.Protected
    if (f.isInternal) flags = flags.or(0x00000008)     // FConst.Internal
    if (f.isStatic) flags = flags.or(0x00000800)       // FConst.Static
    if (f.isVirtual) flags = flags.or(0x00001000)      // FConst.Virtual
    if (f.isOverride) flags = flags.or(0x00000200)     // FConst.Override
    if (f.isConst) flags = flags.or(0x00002000)        // FConst.Const
    return flags
  }

  ** Calculate setter-specific flags
  ** For fields like "Int x { private set }", the setter has different visibility
  ** than the field itself. Returns setter flags if f.set exists, otherwise field flags.
  private Int setterFlags(FieldDef f)
  {
    // If field has no setter accessor method, use field flags
    if (f.set == null) return fieldFlags(f)

    // FConst protection values in the compiler (different from Python emission values!)
    // FConst: Internal=0x80, Private=0x800, Protected=0x1000, Public=0x2000
    setFlags := f.set.flags

    // Check setter's protection using FConst values
    isSetterPublic := setFlags.and(0x00002000) != 0
    isSetterPrivate := setFlags.and(0x00000800) != 0
    isSetterProtected := setFlags.and(0x00001000) != 0
    isSetterInternal := setFlags.and(0x00000080) != 0

    // If setter has no protection flags, inherit from field
    if (!isSetterPublic && !isSetterPrivate && !isSetterProtected && !isSetterInternal)
      return fieldFlags(f)

    // Build output flags using Python-compatible values
    // Python emission values: Public=0x1, Private=0x2, Protected=0x4, Internal=0x8
    flags := 0
    if (isSetterPublic) flags = flags.or(0x00000001)
    if (isSetterPrivate) flags = flags.or(0x00000002)
    if (isSetterProtected) flags = flags.or(0x00000004)
    if (isSetterInternal) flags = flags.or(0x00000008)

    // Non-protection flags from field (using Python emission values)
    if (f.isStatic) flags = flags.or(0x00000800)       // Static
    if (f.isVirtual) flags = flags.or(0x00001000)      // Virtual
    if (f.isOverride) flags = flags.or(0x00000200)     // Override
    if (f.isConst) flags = flags.or(0x00002000)        // Const

    return flags
  }

  ** Calculate method flags
  private Int methodFlags(MethodDef m)
  {
    flags := 0
    if (m.isPublic) flags = flags.or(0x00000001)       // FConst.Public
    if (m.isPrivate) flags = flags.or(0x00000002)      // FConst.Private
    if (m.isProtected) flags = flags.or(0x00000004)    // FConst.Protected
    if (m.isInternal) flags = flags.or(0x00000008)     // FConst.Internal
    if (m.isCtor) flags = flags.or(0x00000100)         // FConst.Ctor
    if (m.isStatic) flags = flags.or(0x00000800)       // FConst.Static
    if (m.isVirtual) flags = flags.or(0x00001000)      // FConst.Virtual
    if (m.isAbstract) flags = flags.or(0x00000400)     // FConst.Abstract
    if (m.isOverride) flags = flags.or(0x00000200)     // FConst.Override
    return flags
  }

  ** Calculate type flags (Mixin, Facet, Internal, Const, etc.)
  private Int typeFlags(TypeDef t)
  {
    flags := 0
    if (t.isPublic) flags = flags.or(0x00000001)       // FConst.Public
    if (t.isInternal) flags = flags.or(0x00000008)     // FConst.Internal
    if (t.isAbstract) flags = flags.or(0x00000400)     // FConst.Abstract
    if (t.isConst) flags = flags.or(0x00002000)        // FConst.Const
    if (t.isFinal) flags = flags.or(0x00010000)        // FConst.Final
    if (t.isMixin) flags = flags.or(0x00020000)        // FConst.Mixin
    if (t.isEnum) flags = flags.or(0x00040000)         // FConst.Enum
    if (t.isFacet) flags = flags.or(0x00080000)        // FConst.Facet
    return flags
  }

  ** Check if a statement is a static field assignment for one of the given fields
  ** Used to skip duplicate initializations in static init blocks
  private Bool isStaticFieldAssignment(Stmt s, Str[] fieldNames)
  {
    // Check for expression statement with assignment
    if (s.id != StmtId.expr) return false
    exprStmt := s as ExprStmt
    if (exprStmt.expr.id != ExprId.assign) return false

    // Check if LHS is a field reference
    assignExpr := exprStmt.expr as BinaryExpr
    if (assignExpr.lhs.id != ExprId.field) return false

    fieldExpr := assignExpr.lhs as FieldExpr
    if (!fieldExpr.field.isStatic) return false

    // Check if the field name is in our list
    return fieldNames.contains(fieldExpr.field.name)
  }

  ** Check if a statement assigns to an enum value field
  ** Used to filter out enum value initialization from _static_init() since
  ** enum values are handled by vals()/_make_enum() instead
  private Bool isEnumFieldAssignment(Stmt s, Str:Bool enumFieldNames)
  {
    // Check for expression statement with assignment
    if (s.id != StmtId.expr) return false
    exprStmt := s as ExprStmt
    if (exprStmt.expr.id != ExprId.assign) return false

    // Check if LHS is a field reference
    assignExpr := exprStmt.expr as BinaryExpr
    if (assignExpr.lhs.id != ExprId.field) return false

    fieldExpr := assignExpr.lhs as FieldExpr
    if (!fieldExpr.field.isStatic) return false

    // Check if it's an enum field
    return enumFieldNames.containsKey(fieldExpr.field.name)
  }
}
