//
// Copyright (c) 2025, Brian Frank and Andy Frank
// Licensed under the Academic Free License version 3.0
//
// History:
//   Dec 2025  Creation
//

using build
using compiler
using util

**
** Python transpiler command
**
internal class PythonCmd : TranspileCmd
{
  override Str name() { "py" }

  override Str summary() { "Transpile to Python" }

  override Int usage(OutStream out := Env.cur.out)
  {
    ret := super.usage(out)
    out.printLine("Examples:")
    out.printLine("  fanc py foo              // generate Python source for 'foo' pod and its depends")
    return ret
  }

  override Void genPod(PodDef pod)
  {
    // Create fan/__init__.py namespace package if it doesn't exist
    fanDir := outDir + `fan/`
    fanDir.create
    fanInit := fanDir + `__init__.py`
    if (!fanInit.exists)
    {
      fanInit.out.printLine("# Fantom Python namespace package").printLine("# Auto-generated by fanc py").close
    }

    // Create lazy loader __init__.py for the pod package
    initFile := PyUtil.podDir(outDir, pod.name) + `__init__.py`
    initFile.parent.create
    initOut := initFile.out

    // Check for hand-written natives directory
    nativeDir := findNativeDir(pod.name)

    // Generate all types
    pod.typeDefs.each |t|
    {
      if (t.isSynthetic) return
      genTypeWithNative(t, nativeDir)
    }

    // Collect type names for lazy loader
    typeNames := Str[,]
    pod.typeDefs.each |t|
    {
      if (t.isSynthetic) return
      typeNames.add(t.name)
    }

    // Also include extra native types (ObjUtil, etc.)
    if (nativeDir != null)
    {
      nativeDir.list.each |f|
      {
        if (f.ext != "py") return
        typeName := f.basename
        if (!typeNames.contains(typeName))
          typeNames.add(typeName)
      }
    }

    // Write lazy loader __init__.py
    writeLazyLoader(initOut, pod.name, typeNames)
    initOut.close

    // Copy runtime files (fanx module) for sys pod
    if (pod.name == "sys")
    {
      copyRuntime(pod.name)
    }

    // Copy any extra native files that don't have corresponding types
    // (e.g., ObjUtil.py, SyntheticFile.py, etc.)
    if (nativeDir != null)
    {
      copyExtraNatives(pod, nativeDir)
    }

    // Extract web assets (JS, CSS, resources) from the pre-built pod file
    // Assets go into fan/_assets/ to keep them co-located with the serving code
    extractAssets(pod.name)
  }

//////////////////////////////////////////////////////////////////////////
// Asset Extraction
//////////////////////////////////////////////////////////////////////////

  **
  ** Extract all web assets (JS, CSS, resources) from the pre-built pod file.
  ** Assets are placed in fan/_assets/ following Python packaging best practices,
  ** keeping static files co-located with the code that serves them (fan/web/FilePack.py).
  **
  ** Package Size Notes:
  ** -------------------
  ** Current extraction includes ALL JS files, resulting in ~10MB uncompressed assets.
  ** For production releases, consider adding a flag to skip test JS files:
  **
  **   test*.js files (~2.6MB uncompressed):
  **     - testSys.js (1.4MB) - Fantom sys tests for browser JS runtime
  **     - testXeto.js, testHaystack.js, testAxon.js, testDomkit.js, testGraphics.js
  **
  ** These test JS files are for browser-based testing of the JavaScript runtime,
  ** not for testing the Python transpilation. To reduce wheel size for production:
  **
  **   1. Add a --production flag to fanc py
  **   2. In extractJs(), skip files where pod.name.startsWith("test")
  **   3. This would reduce the wheel from ~2.2MB to ~1.4MB compressed
  **
  private Void extractAssets(Str podName)
  {
    podObj := Pod.find(podName, false)
    if (podObj == null) return

    extractJs(podObj)
    extractResources(podObj)
  }

  ** Extract JavaScript and source maps from pod
  private Void extractJs(Pod pod)
  {
    // Place JS in fan/_assets/js/ (co-located with fan/web/FilePack.py)
    jsDir := outDir + `fan/_assets/js/`
    jsDir.create

    // Try ES6 first (/js/{pod}.js), then legacy (/{pod}.js)
    jsFile := pod.file(`/js/${pod.name}.js`, false)
             ?: pod.file(`/${pod.name}.js`, false)
    if (jsFile != null)
    {
      outFile := jsDir + `${pod.name}.js`
      jsFile.copyTo(outFile, ["overwrite": true])
      info("  Extracted ${pod.name}.js")
    }

    // Also extract fan.js for sys pod (ES6 module system bootstrap)
    if (pod.name == "sys")
    {
      fanJs := pod.file(`/js/fan.js`, false)
      if (fanJs != null)
      {
        outFile := jsDir + `fan.js`
        fanJs.copyTo(outFile, ["overwrite": true])
        info("  Extracted fan.js")
      }
    }

    // Source map (try ES6 location first, then legacy)
    mapFile := pod.file(`/js/${pod.name}.js.map`, false)
              ?: pod.file(`/${pod.name}.js.map`, false)
    if (mapFile != null)
    {
      outFile := jsDir + `${pod.name}.js.map`
      mapFile.copyTo(outFile, ["overwrite": true])
    }
  }

  ** Extract all resources (CSS, images, data files) from pod
  private Void extractResources(Pod pod)
  {
    // Place resources in fan/_assets/res/{podName}/ to avoid collisions
    // between pods that have files with the same name (e.g., style.css)
    resDir := outDir + `fan/_assets/res/${pod.name}/`

    // Get all files in the pod and filter for res/
    // URIs are like: fan://podName/res/css/file.css
    pod.files.each |file|
    {
      // Get the path part of the URI (e.g., "/res/css/domkit.css")
      path := file.uri.pathStr
      if (path.startsWith("/res/"))
      {
        // Preserve directory structure under res/{podName}/
        relPath := path[5..-1]  // Strip "/res/"
        outFile := resDir + relPath.toUri
        outFile.parent.create
        file.copyTo(outFile, ["overwrite": true])

        // Log CSS files specifically
        if (file.ext == "css")
          info("  Extracted ${pod.name}/${file.name}")
      }
    }
  }

  ** Copy native files that don't have corresponding type definitions
  ** These are utility modules like ObjUtil.py that are hand-written only
  private Void copyExtraNatives(PodDef pod, File nativeDir)
  {
    // Get set of type names that have type definitions
    typeNames := Str:Bool[:]
    pod.typeDefs.each |t| { typeNames[t.name] = true }

    // Copy any .py files that don't have corresponding types
    nativeDir.list.each |f|
    {
      if (f.ext != "py") return
      typeName := f.basename

      // Special handling for __init__.py: prepend native content to the
      // generated lazy loader rather than overwriting it. The lazy loader
      // contains the _types dict needed by Pod.types() for type discovery.
      if (typeName == "__init__")
      {
        initFile := PyUtil.podDir(outDir, pod.name) + `__init__.py`
        existingContent := initFile.readAllStr
        nativeContent := f.readAllStr
        out := initFile.out
        try
        {
          out.print(nativeContent)
          out.printLine("")
          out.printLine("# ---- Generated lazy loader (do not edit below) ----")
          out.printLine("")
          out.print(existingContent)
        }
        finally out.close
        return
      }

      if (typeNames[typeName] != true)
      {
        // This is an extra native file - copy it directly
        outFile := PyUtil.podDir(outDir, pod.name) + `${f.name}`
        f.copyTo(outFile, ["overwrite": true])
      }
    }
  }

  ** Find the native Python directory for a pod
  ** Uses pyFiles from compiler input (via dynamic access for bootstrap compatibility)
  private File? findNativeDir(Str podName)
  {
    // Use pyFiles from compiler input (dynamic access for bootstrap compatibility)
    try
    {
      input := compiler?.input
      pyFiles := input?->pyFiles as Uri[]
      if (pyFiles != null && !pyFiles.isEmpty)
      {
        baseDir := input.baseDir
        // pyFiles are relative paths like `py/`
        // Return the first one that exists
        return pyFiles.eachWhile |uri|
        {
          dir := baseDir.plus(uri)
          return dir.exists ? dir : null
        }
      }
    }
    catch (Err e) { /* pyFiles not available in bootstrap - use fallback */ }

    // Fallback: look in standard locations
    // Try py/fan/ first (sys pod pattern), then py/ (other pods)
    File? result := null
    Env.cur.path.each |path|
    {
      if (result != null) return

      // Try py/fan/ (sys pod)
      nativeDir := path + `src/${podName}/py/fan/`
      if (nativeDir.exists)
      {
        result = nativeDir
        return
      }

      // Try py/ directly (concurrent, util, etc.)
      nativeDir = path + `src/${podName}/py/`
      if (nativeDir.exists)
        result = nativeDir
    }
    return result
  }

  ** Generate a type, merging with native if available
  private Void genTypeWithNative(TypeDef t, File? nativeDir)
  {
    outFile := PyUtil.typeFile(outDir, t)
    outFile.parent.create

    // Check for hand-written native file
    nativeFile := nativeDir != null ? nativeDir + `${t.name}.py` : null

    if (nativeFile != null && nativeFile.exists)
    {
      // Merge: native file + transpiled metadata
      mergeNativeWithMetadata(t, nativeFile, outFile)
    }
    else
    {
      // No native - use fully transpiled output
      out := outFile.out
      try
      {
        PyTypePrinter(out).type(t)
      }
      finally
      {
        out.close
      }
    }
  }

  ** Merge hand-written native file with transpiled metadata
  private Void mergeNativeWithMetadata(TypeDef t, File nativeFile, File outFile)
  {
    // First generate the transpiled output to a buffer to extract metadata
    buf := StrBuf()
    PyTypePrinter(buf.out).type(t)
    transpiled := buf.toStr

    // Extract metadata section (# Type metadata... to end of file)
    metadataStart := transpiled.index("# Type metadata")
    metadata := metadataStart != null ? transpiled[metadataStart..-1] : null

    // Write merged output
    out := outFile.out
    try
    {
      // Copy native file content
      out.print(nativeFile.readAllStr)

      // Append metadata if we have it
      if (metadata != null)
      {
        out.printLine("")
        // For sys pod: metadata uses bare Type.find() since Type is in the same pod
        // For other pods: metadata uses sys.Type.find() via qualified import
        if (t.pod.name == "sys")
          out.printLine("from fan.sys.Type import Type")
        else
          out.printLine("import fan.sys as sys")
        out.print(metadata)
      }
    }
    finally
    {
      out.close
    }
  }

  ** Copy runtime files (fanx module, etc.)
  private Void copyRuntime(Str podName)
  {
    // Look for fanx module in the pod's source tree
    Env.cur.path.each |path|
    {
      fanxDir := path + `src/${podName}/py/fanx/`
      if (fanxDir.exists)
      {
        // Create output fanx directory
        outFanxDir := outDir + `fanx/`
        outFanxDir.create

        // Copy all .py files from fanx module
        fanxDir.list.each |f|
        {
          if (f.ext == "py")
          {
            outFile := outFanxDir + `${f.name}`
            f.copyTo(outFile, ["overwrite": true])
          }
        }
        return
      }
    }
  }

  ** Legacy method - kept for compatibility but not used
  override Void genType(TypeDef t)
  {
    if (t.isSynthetic) return

    outFile := PyUtil.typeFile(outDir, t)
    outFile.parent.create

    out := outFile.out
    try
    {
      PyTypePrinter(out).type(t)
    }
    finally
    {
      out.close
    }
  }

  ** Write lazy loader __init__.py for a pod
  ** This creates a module that lazily imports types on first access,
  ** avoiding circular import issues and reducing startup time.
  ** Uses module-level __getattr__ (Python 3.7+) to preserve package semantics.
  private Void writeLazyLoader(OutStream out, Str podName, Str[] typeNames)
  {
    out.printLine("\"\"\"")
    out.printLine("${podName} pod - Lazy loader module")
    out.printLine("Auto-generated by fanc py")
    out.printLine("")
    out.printLine("This module lazily imports types on first access to avoid circular imports")
    out.printLine("and reduce startup time. Access types via: from fan import ${podName}; ${podName}.TypeName")
    out.printLine("\"\"\"")
    out.printLine("")
    out.printLine("import importlib")
    out.printLine("")
    out.printLine("# Cache for loaded types")
    out.printLine("_cache = {}")
    out.printLine("_loading = set()  # Prevent circular import loops")
    out.printLine("")
    out.printLine("# Known types in this pod")
    out.printLine("_types = {")
    typeNames.each |name, i|
    {
      comma := i < typeNames.size - 1 ? "," : ""
      out.printLine("    '${name}': '${name}'${comma}")
    }
    out.printLine("}")
    out.printLine("")
    out.printLine("def __getattr__(name):")
    out.printLine("    \"\"\"Module-level __getattr__ for lazy type loading (Python 3.7+).\"\"\"")
    out.printLine("    if name.startswith('_'):")
    out.printLine("        raise AttributeError(name)")
    out.printLine("")
    out.printLine("    # Check cache first")
    out.printLine("    if name in _cache:")
    out.printLine("        return _cache[name]")
    out.printLine("")
    out.printLine("    # Prevent circular imports")
    out.printLine("    if name in _loading:")
    out.printLine("        return None  # Return None during circular load")
    out.printLine("")
    out.printLine("    # Check if this is a known type")
    out.printLine("    if name not in _types:")
    out.printLine("        raise AttributeError(f\"module 'fan.${podName}' has no attribute '{name}'\")")
    out.printLine("")
    out.printLine("    _loading.add(name)")
    out.printLine("    try:")
    out.printLine("        # Import the module")
    out.printLine("        module = importlib.import_module(f'fan.${podName}.{name}')")
    out.printLine("        # Get the class from the module")
    out.printLine("        cls = getattr(module, name, None)")
    out.printLine("        if cls is not None:")
    out.printLine("            _cache[name] = cls")
    out.printLine("            return cls")
    out.printLine("        raise AttributeError(f\"fan.${podName}.{name} has no class {name}\")")
    out.printLine("    finally:")
    out.printLine("        _loading.discard(name)")
    out.printLine("")
    out.printLine("def __dir__():")
    out.printLine("    \"\"\"Return list of available types for IDE completion.\"\"\"")
    out.printLine("    return list(_types.keys())")
  }
}
