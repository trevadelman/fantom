//
// Copyright (c) 2025, Brian Frank and Andy Frank
// Licensed under the Academic Free License version 3.0
//
// History:
//   Dec 2025  Creation
//

using build
using compiler
using util

**
** Python transpiler command
**
internal class PythonCmd : TranspileCmd
{
  override Str name() { "py" }

  override Str summary() { "Transpile to Python" }

  override Int usage(OutStream out := Env.cur.out)
  {
    ret := super.usage(out)
    out.printLine("Examples:")
    out.printLine("  fanc py foo              // generate Python source for 'foo' pod and its depends")
    return ret
  }

  override Void genPod(PodDef pod)
  {
    // Create fan/__init__.py namespace package if it doesn't exist
    fanDir := outDir + `fan/`
    fanDir.create
    fanInit := fanDir + `__init__.py`
    if (!fanInit.exists)
    {
      fanInit.out.printLine("# Fantom Python namespace package").printLine("# Auto-generated by fanc py").close
    }

    // Create lazy loader __init__.py for the pod package
    initFile := PyUtil.podDir(outDir, pod.name) + `__init__.py`
    initFile.parent.create
    initOut := initFile.out

    // Check for hand-written natives directory
    nativeDir := findNativeDir(pod.name)

    // Generate all types
    pod.typeDefs.each |t|
    {
      if (t.isSynthetic) return
      genTypeWithNative(t, nativeDir)
    }

    // Collect type names for lazy loader
    typeNames := Str[,]
    pod.typeDefs.each |t|
    {
      if (t.isSynthetic) return
      typeNames.add(t.name)
    }

    // Also include extra native types (ObjUtil, etc.)
    if (nativeDir != null)
    {
      nativeDir.list.each |f|
      {
        if (f.ext != "py") return
        typeName := f.basename
        if (!typeNames.contains(typeName))
          typeNames.add(typeName)
      }
    }

    // Write lazy loader __init__.py
    writeLazyLoader(initOut, pod.name, typeNames)
    initOut.close

    // Copy runtime files (fanx module) for sys pod
    if (pod.name == "sys")
    {
      copyRuntime(pod.name)
    }

    // Copy any extra native files that don't have corresponding types
    // (e.g., ObjUtil.py, SyntheticFile.py, etc.)
    if (nativeDir != null)
    {
      copyExtraNatives(pod, nativeDir)
    }
  }

  ** Copy native files that don't have corresponding type definitions
  ** These are utility modules like ObjUtil.py that are hand-written only
  private Void copyExtraNatives(PodDef pod, File nativeDir)
  {
    // Get set of type names that have type definitions
    typeNames := Str:Bool[:]
    pod.typeDefs.each |t| { typeNames[t.name] = true }

    // Copy any .py files that don't have corresponding types
    nativeDir.list.each |f|
    {
      if (f.ext != "py") return
      typeName := f.basename
      if (typeNames[typeName] != true)
      {
        // This is an extra native file - copy it directly
        outFile := PyUtil.podDir(outDir, pod.name) + `${f.name}`
        f.copyTo(outFile, ["overwrite": true])
      }
    }
  }

  ** Find the native Python directory for a pod
  ** Uses pyFiles from compiler input (via dynamic access for bootstrap compatibility)
  private File? findNativeDir(Str podName)
  {
    // Use pyFiles from compiler input (dynamic access for bootstrap compatibility)
    try
    {
      input := compiler?.input
      pyFiles := input?->pyFiles as Uri[]
      if (pyFiles != null && !pyFiles.isEmpty)
      {
        baseDir := input.baseDir
        // pyFiles are relative paths like `py/`
        // Return the first one that exists
        return pyFiles.eachWhile |uri|
        {
          dir := baseDir.plus(uri)
          return dir.exists ? dir : null
        }
      }
    }
    catch (Err e) { /* pyFiles not available in bootstrap - use fallback */ }

    // Fallback: look in standard locations
    // Try py/fan/ first (sys pod pattern), then py/ (other pods)
    File? result := null
    Env.cur.path.each |path|
    {
      if (result != null) return

      // Try py/fan/ (sys pod)
      nativeDir := path + `src/${podName}/py/fan/`
      if (nativeDir.exists)
      {
        result = nativeDir
        return
      }

      // Try py/ directly (concurrent, util, etc.)
      nativeDir = path + `src/${podName}/py/`
      if (nativeDir.exists)
        result = nativeDir
    }
    return result
  }

  ** Generate a type, merging with native if available
  private Void genTypeWithNative(TypeDef t, File? nativeDir)
  {
    outFile := PyUtil.typeFile(outDir, t)
    outFile.parent.create

    // Check for hand-written native file
    nativeFile := nativeDir != null ? nativeDir + `${t.name}.py` : null

    if (nativeFile != null && nativeFile.exists)
    {
      // Merge: native file + transpiled metadata
      mergeNativeWithMetadata(t, nativeFile, outFile)
    }
    else
    {
      // No native - use fully transpiled output
      out := outFile.out
      try
      {
        PyTypePrinter(out).type(t)
      }
      finally
      {
        out.close
      }
    }
  }

  ** Merge hand-written native file with transpiled metadata
  private Void mergeNativeWithMetadata(TypeDef t, File nativeFile, File outFile)
  {
    // First generate the transpiled output to a buffer to extract metadata
    buf := StrBuf()
    PyTypePrinter(buf.out).type(t)
    transpiled := buf.toStr

    // Extract metadata section (# Type metadata... to end of file)
    metadataStart := transpiled.index("# Type metadata")
    metadata := metadataStart != null ? transpiled[metadataStart..-1] : null

    // Write merged output
    out := outFile.out
    try
    {
      // Copy native file content
      out.print(nativeFile.readAllStr)

      // Append metadata if we have it
      if (metadata != null)
      {
        out.printLine("")
        // Add sys import before metadata (needed for sys.Type.find() calls)
        // The transpiler uses sys.Type.find() for non-sys pods
        out.printLine("import fan.sys as sys")
        out.print(metadata)
      }
    }
    finally
    {
      out.close
    }
  }

  ** Copy runtime files (fanx module, etc.)
  private Void copyRuntime(Str podName)
  {
    // Look for fanx module in the pod's source tree
    Env.cur.path.each |path|
    {
      fanxDir := path + `src/${podName}/py/fanx/`
      if (fanxDir.exists)
      {
        // Create output fanx directory
        outFanxDir := outDir + `fanx/`
        outFanxDir.create

        // Copy all .py files from fanx module
        fanxDir.list.each |f|
        {
          if (f.ext == "py")
          {
            outFile := outFanxDir + `${f.name}`
            f.copyTo(outFile, ["overwrite": true])
          }
        }
        return
      }
    }
  }

  ** Legacy method - kept for compatibility but not used
  override Void genType(TypeDef t)
  {
    if (t.isSynthetic) return

    outFile := PyUtil.typeFile(outDir, t)
    outFile.parent.create

    out := outFile.out
    try
    {
      PyTypePrinter(out).type(t)
    }
    finally
    {
      out.close
    }
  }

  ** Write lazy loader __init__.py for a pod
  ** This creates a module that lazily imports types on first access,
  ** avoiding circular import issues and reducing startup time.
  ** Uses module-level __getattr__ (Python 3.7+) to preserve package semantics.
  private Void writeLazyLoader(OutStream out, Str podName, Str[] typeNames)
  {
    out.printLine("\"\"\"")
    out.printLine("${podName} pod - Lazy loader module")
    out.printLine("Auto-generated by fanc py")
    out.printLine("")
    out.printLine("This module lazily imports types on first access to avoid circular imports")
    out.printLine("and reduce startup time. Access types via: from fan import ${podName}; ${podName}.TypeName")
    out.printLine("\"\"\"")
    out.printLine("")
    out.printLine("import importlib")
    out.printLine("")
    out.printLine("# Cache for loaded types")
    out.printLine("_cache = {}")
    out.printLine("_loading = set()  # Prevent circular import loops")
    out.printLine("")
    out.printLine("# Known types in this pod")
    out.printLine("_types = {")
    typeNames.each |name, i|
    {
      comma := i < typeNames.size - 1 ? "," : ""
      out.printLine("    '${name}': '${name}'${comma}")
    }
    out.printLine("}")
    out.printLine("")
    out.printLine("def __getattr__(name):")
    out.printLine("    \"\"\"Module-level __getattr__ for lazy type loading (Python 3.7+).\"\"\"")
    out.printLine("    if name.startswith('_'):")
    out.printLine("        raise AttributeError(name)")
    out.printLine("")
    out.printLine("    # Check cache first")
    out.printLine("    if name in _cache:")
    out.printLine("        return _cache[name]")
    out.printLine("")
    out.printLine("    # Prevent circular imports")
    out.printLine("    if name in _loading:")
    out.printLine("        return None  # Return None during circular load")
    out.printLine("")
    out.printLine("    # Check if this is a known type")
    out.printLine("    if name not in _types:")
    out.printLine("        raise AttributeError(f\"module 'fan.${podName}' has no attribute '{name}'\")")
    out.printLine("")
    out.printLine("    _loading.add(name)")
    out.printLine("    try:")
    out.printLine("        # Import the module")
    out.printLine("        module = importlib.import_module(f'fan.${podName}.{name}')")
    out.printLine("        # Get the class from the module")
    out.printLine("        cls = getattr(module, name, None)")
    out.printLine("        if cls is not None:")
    out.printLine("            _cache[name] = cls")
    out.printLine("            return cls")
    out.printLine("        raise AttributeError(f\"fan.${podName}.{name} has no class {name}\")")
    out.printLine("    finally:")
    out.printLine("        _loading.discard(name)")
    out.printLine("")
    out.printLine("def __dir__():")
    out.printLine("    \"\"\"Return list of available types for IDE completion.\"\"\"")
    out.printLine("    return list(_types.keys())")
  }
}
