//
// Copyright (c) 2025, Brian Frank and Andy Frank
// Licensed under the Academic Free License version 3.0
//
// History:
//   Dec 2025  Creation
//

using build
using compiler
using util

**
** Python transpiler command
**
internal class PythonCmd : TranspileCmd
{
  override Str name() { "py" }

  override Str summary() { "Transpile to Python" }

  override Int usage(OutStream out := Env.cur.out)
  {
    ret := super.usage(out)
    out.printLine("Examples:")
    out.printLine("  fanc py foo              // generate Python source for 'foo' pod and its depends")
    return ret
  }

  override Void genPod(PodDef pod)
  {
    // Create fan/__init__.py namespace package if it doesn't exist
    fanDir := outDir + `fan/`
    fanDir.create
    fanInit := fanDir + `__init__.py`
    if (!fanInit.exists)
    {
      fanInit.out.printLine("# Fantom Python namespace package").printLine("# Auto-generated by fanc py").close
    }

    // Create __init__.py for the pod package
    initFile := PyUtil.podDir(outDir, pod.name) + `__init__.py`
    initFile.parent.create
    initOut := initFile.out
    initOut.printLine("# ${pod.name} pod")
    initOut.printLine("# Auto-generated by fanc py")

    // Check for hand-written natives directory
    nativeDir := findNativeDir(pod.name)

    // Generate all types
    pod.typeDefs.each |t|
    {
      if (t.isSynthetic) return
      genTypeWithNative(t, nativeDir)
    }

    // Add imports to __init__.py
    pod.typeDefs.each |t|
    {
      if (t.isSynthetic) return
      initOut.printLine("from .${t.name} import ${t.name}")
    }
    initOut.close

    // Copy runtime files (fanx module) for sys pod
    if (pod.name == "sys")
    {
      copyRuntime(pod.name)
    }

    // Copy any extra native files that don't have corresponding types
    // (e.g., ObjUtil.py, SyntheticFile.py, etc.)
    if (nativeDir != null)
    {
      copyExtraNatives(pod, nativeDir)
    }
  }

  ** Copy native files that don't have corresponding type definitions
  ** These are utility modules like ObjUtil.py that are hand-written only
  private Void copyExtraNatives(PodDef pod, File nativeDir)
  {
    // Get set of type names that have type definitions
    typeNames := Str:Bool[:]
    pod.typeDefs.each |t| { typeNames[t.name] = true }

    // Copy any .py files that don't have corresponding types
    nativeDir.list.each |f|
    {
      if (f.ext != "py") return
      typeName := f.basename
      if (typeNames[typeName] != true)
      {
        // This is an extra native file - copy it directly
        outFile := PyUtil.podDir(outDir, pod.name) + `${f.name}`
        f.copyTo(outFile, ["overwrite": true])
      }
    }
  }

  ** Find the native Python directory for a pod
  ** Uses pyFiles from compiler input (via dynamic access for bootstrap compatibility)
  private File? findNativeDir(Str podName)
  {
    // Use pyFiles from compiler input (dynamic access for bootstrap compatibility)
    try
    {
      input := compiler?.input
      pyFiles := input?->pyFiles as Uri[]
      if (pyFiles != null && !pyFiles.isEmpty)
      {
        baseDir := input.baseDir
        // pyFiles are relative paths like `py/`
        // Return the first one that exists
        return pyFiles.eachWhile |uri|
        {
          dir := baseDir.plus(uri)
          return dir.exists ? dir : null
        }
      }
    }
    catch (Err e) { /* pyFiles not available in bootstrap - use fallback */ }

    // Fallback: look in standard locations
    // Try py/fan/ first (sys pod pattern), then py/ (other pods)
    File? result := null
    Env.cur.path.each |path|
    {
      if (result != null) return

      // Try py/fan/ (sys pod)
      nativeDir := path + `src/${podName}/py/fan/`
      if (nativeDir.exists)
      {
        result = nativeDir
        return
      }

      // Try py/ directly (concurrent, util, etc.)
      nativeDir = path + `src/${podName}/py/`
      if (nativeDir.exists)
        result = nativeDir
    }
    return result
  }

  ** Generate a type, merging with native if available
  private Void genTypeWithNative(TypeDef t, File? nativeDir)
  {
    outFile := PyUtil.typeFile(outDir, t)
    outFile.parent.create

    // Check for hand-written native file
    nativeFile := nativeDir != null ? nativeDir + `${t.name}.py` : null

    if (nativeFile != null && nativeFile.exists)
    {
      // Merge: native file + transpiled metadata
      mergeNativeWithMetadata(t, nativeFile, outFile)
    }
    else
    {
      // No native - use fully transpiled output
      out := outFile.out
      try
      {
        PyTypePrinter(out).type(t)
      }
      finally
      {
        out.close
      }
    }
  }

  ** Merge hand-written native file with transpiled metadata
  private Void mergeNativeWithMetadata(TypeDef t, File nativeFile, File outFile)
  {
    // First generate the transpiled output to a buffer to extract metadata
    buf := StrBuf()
    PyTypePrinter(buf.out).type(t)
    transpiled := buf.toStr

    // Extract metadata section (# Type metadata... to end of file)
    metadataStart := transpiled.index("# Type metadata")
    metadata := metadataStart != null ? transpiled[metadataStart..-1] : null

    // Write merged output
    out := outFile.out
    try
    {
      // Copy native file content
      out.print(nativeFile.readAllStr)

      // Append metadata if we have it
      if (metadata != null)
      {
        out.printLine("")
        // Add Type import before metadata (needed for Type.find() calls)
        out.printLine("from fan.sys.Type import Type")
        out.print(metadata)
      }
    }
    finally
    {
      out.close
    }
  }

  ** Copy runtime files (fanx module, etc.)
  private Void copyRuntime(Str podName)
  {
    // Look for fanx module in the pod's source tree
    Env.cur.path.each |path|
    {
      fanxDir := path + `src/${podName}/py/fanx/`
      if (fanxDir.exists)
      {
        // Create output fanx directory
        outFanxDir := outDir + `fanx/`
        outFanxDir.create

        // Copy all .py files from fanx module
        fanxDir.list.each |f|
        {
          if (f.ext == "py")
          {
            outFile := outFanxDir + `${f.name}`
            f.copyTo(outFile, ["overwrite": true])
          }
        }
        return
      }
    }
  }

  ** Legacy method - kept for compatibility but not used
  override Void genType(TypeDef t)
  {
    if (t.isSynthetic) return

    outFile := PyUtil.typeFile(outDir, t)
    outFile.parent.create

    out := outFile.out
    try
    {
      PyTypePrinter(out).type(t)
    }
    finally
    {
      out.close
    }
  }
}
